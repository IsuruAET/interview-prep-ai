[
  {
    "id": "typescript-1",
    "topic": "typescript",
    "title": "What is TypeScript and Why Use It?",
    "answer": "TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It adds static type checking, better tooling, and improved code maintainability.\r\n\r\n```typescript\r\n// JavaScript\r\nfunction add(a, b) {\r\n  return a + b;\r\n}\r\nadd('5', 3); // '53' (runtime error potential)\r\n\r\n// TypeScript\r\nfunction add(a: number, b: number): number {\r\n  return a + b;\r\n}\r\nadd('5', 3); // Compile-time error: Argument of type 'string' is not assignable to parameter of type 'number'\r\n\r\n// Benefits:\r\n// 1. Type safety at compile time\r\n// 2. Better IDE support (autocomplete, refactoring)\r\n// 3. Self-documenting code\r\n// 4. Catch errors before runtime\r\n// 5. Easier refactoring\r\n```",
    "number": 1
  },
  {
    "id": "typescript-2",
    "topic": "typescript",
    "title": "Explain Type Inference in TypeScript",
    "answer": "TypeScript automatically infers types when they're not explicitly provided.\r\n\r\n```typescript\r\n// Type inference\r\nlet x = 5; // TypeScript infers: number\r\nlet y = 'hello'; // TypeScript infers: string\r\nlet z = [1, 2, 3]; // TypeScript infers: number[]\r\n\r\n// Function return type inference\r\nfunction multiply(a: number, b: number) {\r\n  return a * b; // Return type inferred as number\r\n}\r\n\r\n// Array inference\r\nconst numbers = [1, 2, 3]; // number[]\r\nconst mixed = [1, 'two', 3]; // (string | number)[]\r\n\r\n// Object inference\r\nconst user = {\r\n  name: 'John',\r\n  age: 30\r\n}; // { name: string; age: number }\r\n\r\n// Explicit types when needed\r\nlet value: string | number;\r\nvalue = 'hello'; // OK\r\nvalue = 42; // OK\r\nvalue = true; // Error\r\n\r\n// Best practice: Let TypeScript infer when possible\r\nconst items = [1, 2, 3]; // Good\r\nconst items: number[] = [1, 2, 3]; // Also good, but redundant\r\n```",
    "number": 2
  },
  {
    "id": "typescript-3",
    "topic": "typescript",
    "title": "What's the Difference Between `interface` and `type`?",
    "answer": "Both define object shapes, but have different capabilities and use cases.\r\n\r\n```typescript\r\n// Interface - can be extended and merged\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\ninterface Admin extends User {\r\n  role: 'admin';\r\n}\r\n\r\n// Declaration merging\r\ninterface User {\r\n  email: string; // Merges with previous User interface\r\n}\r\n\r\n// Type - more flexible, can represent unions, intersections, primitives\r\ntype Status = 'pending' | 'approved' | 'rejected';\r\ntype ID = string | number;\r\n\r\ntype UserType = {\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\n// Intersection types\r\ntype AdminType = UserType & {\r\n  role: 'admin';\r\n};\r\n\r\n// Union types\r\ntype Result = Success | Error;\r\n\r\n// When to use interface:\r\n// - Object shapes that might be extended\r\n// - Public APIs (can be augmented via declaration merging)\r\n// - React component props\r\n\r\n// When to use type:\r\n// - Unions, intersections, primitives\r\n// - Mapped types, conditional types\r\n// - Tuple types\r\n// - When you need computed properties\r\n```",
    "number": 3
  },
  {
    "id": "typescript-4",
    "topic": "typescript",
    "title": "Explain Generics in TypeScript",
    "answer": "Generics allow creating reusable components that work with multiple types.\r\n\r\n```typescript\r\n// Basic generic function\r\nfunction identity<T>(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nconst num = identity<number>(5);\r\nconst str = identity<string>('hello');\r\nconst inferred = identity(42); // Type inferred as number\r\n\r\n// Generic interface\r\ninterface Box<T> {\r\n  value: T;\r\n}\r\n\r\nconst numberBox: Box<number> = { value: 5 };\r\nconst stringBox: Box<string> = { value: 'hello' };\r\n\r\n// Generic class\r\nclass Container<T> {\r\n  private items: T[] = [];\r\n  \r\n  add(item: T): void {\r\n    this.items.push(item);\r\n  }\r\n  \r\n  get(index: number): T {\r\n    return this.items[index];\r\n  }\r\n}\r\n\r\nconst numberContainer = new Container<number>();\r\nnumberContainer.add(1);\r\nnumberContainer.add(2);\r\n\r\n// Multiple generics\r\nfunction pair<T, U>(first: T, second: U): [T, U] {\r\n  return [first, second];\r\n}\r\n\r\nconst result = pair<string, number>('age', 30);\r\n\r\n// Generic constraints\r\ninterface Lengthwise {\r\n  length: number;\r\n}\r\n\r\nfunction logLength<T extends Lengthwise>(arg: T): T {\r\n  console.log(arg.length);\r\n  return arg;\r\n}\r\n\r\nlogLength('hello'); // OK\r\nlogLength([1, 2, 3]); // OK\r\nlogLength(5); // Error: number doesn't have length\r\n\r\n// React example\r\nfunction useState<T>(initial: T): [T, (value: T) => void] {\r\n  let state = initial;\r\n  const setState = (value: T) => {\r\n    state = value;\r\n  };\r\n  return [state, setState];\r\n}\r\n```",
    "number": 4
  },
  {
    "id": "typescript-5",
    "topic": "typescript",
    "title": "What are Utility Types and Provide Examples",
    "answer": "Utility types are built-in generic types that transform existing types.\r\n\r\n```typescript\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  age: number;\r\n  active: boolean;\r\n}\r\n\r\n// Partial<T> - makes all properties optional\r\ntype PartialUser = Partial<User>;\r\n// { id?: number; name?: string; ... }\r\n\r\n// Required<T> - makes all properties required\r\ntype RequiredUser = Required<PartialUser>;\r\n\r\n// Pick<T, K> - select specific properties\r\ntype UserPreview = Pick<User, 'id' | 'name'>;\r\n// { id: number; name: string; }\r\n\r\n// Omit<T, K> - exclude specific properties\r\ntype UserWithoutId = Omit<User, 'id'>;\r\n// { name: string; email: string; age: number; active: boolean; }\r\n\r\n// Readonly<T> - makes all properties readonly\r\ntype ReadonlyUser = Readonly<User>;\r\n// All properties become readonly\r\n\r\n// Record<K, T> - create object type with keys K and values T\r\ntype UserRoles = Record<string, 'admin' | 'user' | 'guest'>;\r\n// { [key: string]: 'admin' | 'user' | 'guest' }\r\n\r\n// Exclude<T, U> - exclude types from union\r\ntype NonNullable<T> = Exclude<T, null | undefined>;\r\n\r\n// Extract<T, U> - extract types from union\r\ntype StringOrNumber = Extract<string | number | boolean, string | number>;\r\n\r\n// NonNullable<T> - exclude null and undefined\r\ntype SafeString = NonNullable<string | null | undefined>; // string\r\n\r\n// ReturnType<T> - get return type of function\r\ntype Fn = () => string;\r\ntype Return = ReturnType<Fn>; // string\r\n\r\n// Parameters<T> - get parameters as tuple\r\ntype Fn2 = (a: number, b: string) => void;\r\ntype Params = Parameters<Fn2>; // [number, string]\r\n\r\n// Practical example\r\nfunction updateUser(id: number, updates: Partial<User>): User {\r\n  // Implementation\r\n  return {} as User;\r\n}\r\n\r\nupdateUser(1, { name: 'John' }); // Only update name\r\n```",
    "number": 5
  },
  {
    "id": "typescript-6",
    "topic": "typescript",
    "title": "Explain Type Guards and Type Narrowing",
    "answer": "Type guards narrow types within conditional blocks.\r\n\r\n```typescript\r\n// typeof type guard\r\nfunction processValue(value: string | number) {\r\n  if (typeof value === 'string') {\r\n    // TypeScript knows value is string here\r\n    return value.toUpperCase();\r\n  }\r\n  // TypeScript knows value is number here\r\n  return value.toFixed(2);\r\n}\r\n\r\n// instanceof type guard\r\nclass Dog {\r\n  bark() { return 'woof'; }\r\n}\r\nclass Cat {\r\n  meow() { return 'meow'; }\r\n}\r\n\r\nfunction makeSound(animal: Dog | Cat) {\r\n  if (animal instanceof Dog) {\r\n    return animal.bark(); // TypeScript knows it's Dog\r\n  }\r\n  return animal.meow(); // TypeScript knows it's Cat\r\n}\r\n\r\n// in operator type guard\r\ninterface Bird {\r\n  fly(): void;\r\n}\r\ninterface Fish {\r\n  swim(): void;\r\n}\r\n\r\nfunction move(animal: Bird | Fish) {\r\n  if ('fly' in animal) {\r\n    animal.fly(); // TypeScript knows it's Bird\r\n  } else {\r\n    animal.swim(); // TypeScript knows it's Fish\r\n  }\r\n}\r\n\r\n// Custom type guard function\r\nfunction isString(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\nfunction process(value: unknown) {\r\n  if (isString(value)) {\r\n    // TypeScript knows value is string\r\n    return value.length;\r\n  }\r\n}\r\n\r\n// Discriminated unions\r\ntype Success = {\r\n  status: 'success';\r\n  data: string;\r\n};\r\ntype Error = {\r\n  status: 'error';\r\n  message: string;\r\n};\r\n\r\ntype Result = Success | Error;\r\n\r\nfunction handleResult(result: Result) {\r\n  if (result.status === 'success') {\r\n    console.log(result.data); // TypeScript knows it's Success\r\n  } else {\r\n    console.log(result.message); // TypeScript knows it's Error\r\n  }\r\n}\r\n```",
    "number": 6
  },
  {
    "id": "typescript-7",
    "topic": "typescript",
    "title": "What are Conditional Types?",
    "answer": "Conditional types select types based on conditions, similar to ternary operators.\r\n\r\n```typescript\r\n// Basic conditional type\r\ntype IsArray<T> = T extends any[] ? true : false;\r\ntype Test1 = IsArray<number[]>; // true\r\ntype Test2 = IsArray<string>; // false\r\n\r\n// Extract array element type\r\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\r\ntype Element = ArrayElement<string[]>; // string\r\ntype Element2 = ArrayElement<number[]>; // number\r\n\r\n// Extract function return type\r\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\r\ntype FnReturn = ReturnType<() => string>; // string\r\n\r\n// Extract function parameters\r\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\r\ntype FnParams = Parameters<(a: number, b: string) => void>; // [number, string]\r\n\r\n// NonNullable\r\ntype NonNullable<T> = T extends null | undefined ? never : T;\r\ntype Safe = NonNullable<string | null>; // string\r\n\r\n// Flatten array type\r\ntype Flatten<T> = T extends (infer U)[] ? U : T;\r\ntype Flat = Flatten<string[][]>; // string[]\r\ntype Flat2 = Flatten<number>; // number\r\n\r\n// Deep flatten\r\ntype DeepFlatten<T> = T extends (infer U)[]\r\n  ? U extends any[]\r\n    ? DeepFlatten<U>\r\n    : U\r\n  : T;\r\ntype Deep = DeepFlatten<string[][][]>; // string\r\n\r\n// React component props example\r\ntype ComponentProps<T> = T extends React.ComponentType<infer P> ? P : never;\r\ntype ButtonProps = ComponentProps<typeof Button>;\r\n```",
    "number": 7
  },
  {
    "id": "typescript-8",
    "topic": "typescript",
    "title": "Explain Mapped Types",
    "answer": "Mapped types create new types by transforming properties of existing types.\r\n\r\n```typescript\r\n// Basic mapped type\r\ntype Readonly<T> = {\r\n  readonly [P in keyof T]: T[P];\r\n};\r\n\r\ntype Optional<T> = {\r\n  [P in keyof T]?: T[P];\r\n};\r\n\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\n// { readonly id: number; readonly name: string; readonly email: string; }\r\n\r\n// Modifier mapping\r\ntype MakeOptional<T> = {\r\n  [P in keyof T]?: T[P];\r\n};\r\n\r\ntype MakeRequired<T> = {\r\n  [P in keyof T]-?: T[P];\r\n};\r\n\r\n// Key remapping (TypeScript 4.1+)\r\ntype Getters<T> = {\r\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\r\n};\r\n\r\ntype UserGetters = Getters<User>;\r\n// { getId: () => number; getName: () => string; getEmail: () => string; }\r\n\r\n// Filter properties\r\ntype OnlyStrings<T> = {\r\n  [K in keyof T as T[K] extends string ? K : never]: T[K];\r\n};\r\n\r\ninterface Mixed {\r\n  name: string;\r\n  age: number;\r\n  email: string;\r\n}\r\ntype StringProps = OnlyStrings<Mixed>; // { name: string; email: string; }\r\n\r\n// Practical: API response transformation\r\ntype ApiResponse<T> = {\r\n  data: T;\r\n  status: number;\r\n  message: string;\r\n};\r\n\r\ntype ApiError = {\r\n  error: string;\r\n  code: number;\r\n};\r\n\r\ntype ApiResult<T> = ApiResponse<T> | ApiError;\r\n```",
    "number": 8
  },
  {
    "id": "typescript-9",
    "topic": "typescript",
    "title": "What is the `as` Keyword and When to Use It?",
    "answer": "The `as` keyword performs type assertions, telling TypeScript to treat a value as a specific type.\r\n\r\n```typescript\r\n// Type assertion\r\nconst value: unknown = 'hello';\r\nconst str = value as string;\r\nstr.toUpperCase(); // OK\r\n\r\n// Angle bracket syntax (not in JSX)\r\nconst str2 = <string>value;\r\n\r\n// Asserting to more specific type\r\ninterface Animal {\r\n  name: string;\r\n}\r\ninterface Dog extends Animal {\r\n  breed: string;\r\n}\r\n\r\nconst animal: Animal = { name: 'Max' };\r\nconst dog = animal as Dog; // Assertion (unsafe if wrong)\r\ndog.breed; // TypeScript allows, but runtime error possible\r\n\r\n// Double assertion\r\nconst num = '123' as unknown as number; // Avoid when possible\r\n\r\n// const assertion\r\nconst colors = ['red', 'green', 'blue'] as const;\r\n// Type: readonly [\"red\", \"green\", \"blue\"]\r\n\r\nconst user = {\r\n  name: 'John',\r\n  age: 30\r\n} as const;\r\n// All properties become readonly literals\r\n\r\n// When to use:\r\n// 1. Working with DOM elements\r\nconst button = document.getElementById('btn') as HTMLButtonElement;\r\n\r\n// 2. Narrowing union types (after type guard)\r\nfunction process(value: string | number) {\r\n  if (typeof value === 'string') {\r\n    return (value as string).toUpperCase();\r\n  }\r\n}\r\n\r\n// 3. Working with third-party libraries\r\nconst data = apiResponse as ApiResponse<User>;\r\n\r\n// Best practice: Use type guards instead when possible\r\n```",
    "number": 9
  },
  {
    "id": "typescript-10",
    "topic": "typescript",
    "title": "Explain `keyof` and `typeof` Operators",
    "answer": "`keyof` gets keys of a type, `typeof` gets the type of a value.\r\n\r\n```typescript\r\n// keyof operator\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\ntype UserKeys = keyof User; // 'id' | 'name' | 'email'\r\n\r\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\r\n  return obj[key];\r\n}\r\n\r\nconst user: User = { id: 1, name: 'John', email: 'john@example.com' };\r\nconst name = getProperty(user, 'name'); // Type-safe property access\r\nconst invalid = getProperty(user, 'age'); // Error: 'age' not in User\r\n\r\n// typeof operator\r\nconst colors = ['red', 'green', 'blue'];\r\ntype Colors = typeof colors; // string[]\r\n\r\nconst userObj = {\r\n  name: 'John',\r\n  age: 30,\r\n  active: true\r\n};\r\ntype UserObj = typeof userObj;\r\n// { name: string; age: number; active: boolean; }\r\n\r\n// Combining keyof and typeof\r\nconst config = {\r\n  apiUrl: 'https://api.example.com',\r\n  timeout: 5000,\r\n  retries: 3\r\n} as const;\r\n\r\ntype ConfigKeys = keyof typeof config; // 'apiUrl' | 'timeout' | 'retries'\r\ntype ConfigValues = typeof config[ConfigKeys]; // 'https://api.example.com' | 5000 | 3\r\n\r\n// Practical: Type-safe event handlers\r\nconst handlers = {\r\n  onClick: (e: MouseEvent) => {},\r\n  onChange: (e: Event) => {},\r\n  onSubmit: (e: SubmitEvent) => {}\r\n};\r\n\r\ntype HandlerKeys = keyof typeof handlers;\r\ntype HandlerType<K extends HandlerKeys> = typeof handlers[K];\r\n```",
    "number": 10
  },
  {
    "id": "typescript-11",
    "topic": "typescript",
    "title": "What are Tuple Types?",
    "answer": "Tuples are arrays with fixed length and known types at each position.\r\n\r\n```typescript\r\n// Basic tuple\r\ntype Point = [number, number];\r\nconst point: Point = [10, 20];\r\n\r\n// Named tuple (TypeScript 4.0+)\r\ntype Point2 = [x: number, y: number];\r\n\r\n// Tuple with different types\r\ntype UserInfo = [string, number, boolean];\r\nconst user: UserInfo = ['John', 30, true];\r\n\r\n// Optional tuple elements\r\ntype OptionalTuple = [string, number?];\r\nconst t1: OptionalTuple = ['hello'];\r\nconst t2: OptionalTuple = ['hello', 42];\r\n\r\n// Rest elements in tuple\r\ntype StringNumberBooleans = [string, number, ...boolean[]];\r\nconst snb: StringNumberBooleans = ['hello', 1, true, false];\r\n\r\n// Readonly tuple\r\ntype ReadonlyPoint = readonly [number, number];\r\nconst rp: ReadonlyPoint = [1, 2];\r\n// rp[0] = 3; // Error: readonly\r\n\r\n// Destructuring tuples\r\nconst [x, y] = point;\r\nconst [name, age, active] = user;\r\n\r\n// React useState example\r\ntype UseStateReturn<T> = [T, (value: T) => void];\r\nfunction useState<T>(initial: T): UseStateReturn<T> {\r\n  // Implementation\r\n  return [initial, () => {}];\r\n}\r\n\r\n// Function parameters as tuple\r\ntype Fn = (...args: [string, number]) => void;\r\nconst fn: Fn = (name, age) => {\r\n  console.log(name, age);\r\n};\r\n```",
    "number": 11
  },
  {
    "id": "typescript-12",
    "topic": "typescript",
    "title": "Explain Declaration Merging",
    "answer": "Declaration merging allows multiple declarations with the same name to be combined.\r\n\r\n```typescript\r\n// Interface merging\r\ninterface User {\r\n  name: string;\r\n}\r\n\r\ninterface User {\r\n  age: number;\r\n}\r\n\r\n// Merged: { name: string; age: number; }\r\nconst user: User = {\r\n  name: 'John',\r\n  age: 30\r\n};\r\n\r\n// Namespace merging\r\nnamespace MyLib {\r\n  export function helper() {}\r\n}\r\n\r\nnamespace MyLib {\r\n  export const version = '1.0.0';\r\n}\r\n\r\n// Merged namespace\r\nMyLib.helper();\r\nMyLib.version;\r\n\r\n// Module augmentation\r\n// In a library file\r\ndeclare module './types' {\r\n  interface User {\r\n    email: string;\r\n  }\r\n}\r\n\r\n// Global augmentation\r\ndeclare global {\r\n  interface Window {\r\n    myCustomProperty: string;\r\n  }\r\n}\r\n\r\nwindow.myCustomProperty; // Available\r\n\r\n// Enum merging\r\nenum Colors {\r\n  Red = 'red'\r\n}\r\n\r\nenum Colors {\r\n  Blue = 'blue'\r\n}\r\n\r\n// Merged enum\r\nColors.Red; // 'red'\r\nColors.Blue; // 'blue'\r\n```",
    "number": 12
  },
  {
    "id": "typescript-13",
    "topic": "typescript",
    "title": "What are Template Literal Types?",
    "answer": "Template literal types create string literal types using template literal syntax.\r\n\r\n```typescript\r\n// Basic template literal type\r\ntype Greeting = `Hello, ${string}`;\r\nconst greet: Greeting = 'Hello, World'; // OK\r\nconst invalid: Greeting = 'Hi'; // Error\r\n\r\n// With union types\r\ntype EventName = 'click' | 'change' | 'submit';\r\ntype HandlerName = `on${Capitalize<EventName>}`;\r\n// 'onClick' | 'onChange' | 'onSubmit'\r\n\r\n// Uppercase, Lowercase, Capitalize, Uncapitalize\r\ntype UppercaseExample = Uppercase<'hello'>; // 'HELLO'\r\ntype LowercaseExample = Lowercase<'HELLO'>; // 'hello'\r\ntype CapitalizeExample = Capitalize<'hello'>; // 'Hello'\r\ntype UncapitalizeExample = Uncapitalize<'Hello'>; // 'hello'\r\n\r\n// Complex example: API routes\r\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\r\ntype ApiRoute = `/api/${string}`;\r\ntype ApiEndpoint = `${HttpMethod} ${ApiRoute}`;\r\n\r\nconst endpoint: ApiEndpoint = 'GET /api/users'; // OK\r\nconst endpoint2: ApiEndpoint = 'POST /api/posts'; // OK\r\n\r\n// CSS property names\r\ntype CssProperty = 'margin' | 'padding' | 'border';\r\ntype CssPropertyWithSide = `${CssProperty}-${'top' | 'right' | 'bottom' | 'left'}`;\r\n// 'margin-top' | 'margin-right' | 'margin-bottom' | 'margin-left' | ...\r\n\r\n// React component props\r\ntype ComponentName = 'Button' | 'Input' | 'Card';\r\ntype PropsName = `${ComponentName}Props`;\r\n```",
    "number": 13
  },
  {
    "id": "typescript-14",
    "topic": "typescript",
    "title": "Explain `never` Type and Its Use Cases",
    "answer": "`never` represents values that never occur - functions that never return or unreachable code.\r\n\r\n```typescript\r\n// Function that never returns\r\nfunction throwError(message: string): never {\r\n  throw new Error(message);\r\n}\r\n\r\nfunction infiniteLoop(): never {\r\n  while (true) {}\r\n}\r\n\r\n// Exhaustive checking\r\ntype Status = 'pending' | 'success' | 'error';\r\n\r\nfunction handleStatus(status: Status) {\r\n  switch (status) {\r\n    case 'pending':\r\n      return 'Loading...';\r\n    case 'success':\r\n      return 'Done';\r\n    case 'error':\r\n      return 'Failed';\r\n    default:\r\n      const exhaustive: never = status; // Ensures all cases handled\r\n      return exhaustive;\r\n  }\r\n}\r\n\r\n// Removing types from unions\r\ntype NonNullable<T> = T extends null | undefined ? never : T;\r\ntype Safe = NonNullable<string | null | undefined>; // string\r\n\r\n// Empty arrays\r\nconst empty: never[] = [];\r\n// empty.push(1); // Error: Argument of type 'number' is not assignable to parameter of type 'never'\r\n\r\n// Type narrowing to never\r\nfunction process(value: string | number) {\r\n  if (typeof value === 'string') {\r\n    return value.toUpperCase();\r\n  }\r\n  if (typeof value === 'number') {\r\n    return value.toFixed(2);\r\n  }\r\n  // value is never here\r\n  const check: never = value; // OK - exhaustive check\r\n}\r\n\r\n// Discriminated union exhaustiveness\r\ntype Result = \r\n  | { type: 'success'; data: string }\r\n  | { type: 'error'; message: string };\r\n\r\nfunction handle(result: Result) {\r\n  switch (result.type) {\r\n    case 'success':\r\n      return result.data;\r\n    case 'error':\r\n      return result.message;\r\n    default:\r\n      const _exhaustive: never = result; // Compile-time check\r\n  }\r\n}\r\n```",
    "number": 14
  },
  {
    "id": "typescript-15",
    "topic": "typescript",
    "title": "What are Index Signatures?",
    "answer": "Index signatures define types for dynamic property access on objects.\r\n\r\n```typescript\r\n// String index signature\r\ninterface StringDictionary {\r\n  [key: string]: string;\r\n}\r\n\r\nconst dict: StringDictionary = {\r\n  name: 'John',\r\n  city: 'NYC'\r\n};\r\ndict['age'] = '30'; // OK\r\n\r\n// Number index signature\r\ninterface NumberDictionary {\r\n  [index: number]: string;\r\n}\r\n\r\nconst arr: NumberDictionary = ['a', 'b', 'c'];\r\narr[0]; // 'a'\r\n\r\n// Both string and number\r\ninterface MixedDictionary {\r\n  [key: string]: string | number;\r\n  [index: number]: string; // Must be subtype of string index\r\n}\r\n\r\n// Readonly index signature\r\ninterface ReadonlyDict {\r\n  readonly [key: string]: string;\r\n}\r\n\r\nconst readonly: ReadonlyDict = { name: 'John' };\r\n// readonly['age'] = '30'; // Error: readonly\r\n\r\n// Practical: API responses\r\ninterface ApiResponse {\r\n  [key: string]: any;\r\n  status: number;\r\n  message: string;\r\n}\r\n\r\n// Record utility type (alternative)\r\ntype StringDict = Record<string, string>;\r\ntype NumberDict = Record<number, string>;\r\n\r\n// React component props with index signature\r\ninterface ComponentProps {\r\n  [key: string]: any;\r\n  className?: string;\r\n  id?: string;\r\n}\r\n```",
    "number": 15
  },
  {
    "id": "typescript-16",
    "topic": "typescript",
    "title": "Explain Function Overloads",
    "answer": "Function overloads provide multiple type signatures for a single function.\r\n\r\n```typescript\r\n// Function overloads\r\nfunction format(value: string): string;\r\nfunction format(value: number): string;\r\nfunction format(value: boolean): string;\r\nfunction format(value: string | number | boolean): string {\r\n  return String(value);\r\n}\r\n\r\nformat('hello'); // OK\r\nformat(42); // OK\r\nformat(true); // OK\r\n\r\n// Different return types\r\nfunction parse(value: string): number;\r\nfunction parse(value: number): string;\r\nfunction parse(value: string | number): number | string {\r\n  if (typeof value === 'string') {\r\n    return parseInt(value);\r\n  }\r\n  return String(value);\r\n}\r\n\r\n// Method overloads\r\nclass Calculator {\r\n  add(a: number, b: number): number;\r\n  add(a: string, b: string): string;\r\n  add(a: number | string, b: number | string): number | string {\r\n    if (typeof a === 'number' && typeof b === 'number') {\r\n      return a + b;\r\n    }\r\n    return String(a) + String(b);\r\n  }\r\n}\r\n\r\n// React event handler example\r\nfunction handleEvent(\r\n  event: MouseEvent,\r\n  handler: (e: MouseEvent) => void\r\n): void;\r\nfunction handleEvent(\r\n  event: KeyboardEvent,\r\n  handler: (e: KeyboardEvent) => void\r\n): void;\r\nfunction handleEvent(\r\n  event: MouseEvent | KeyboardEvent,\r\n  handler: (e: MouseEvent | KeyboardEvent) => void\r\n): void {\r\n  handler(event);\r\n}\r\n```",
    "number": 16
  },
  {
    "id": "typescript-17",
    "topic": "typescript",
    "title": "What are Branded Types and Nominal Typing?",
    "answer": "Branded types create distinct types from the same underlying type, preventing accidental mixing.\r\n\r\n```typescript\r\n// Branded type pattern\r\ntype UserId = string & { __brand: 'UserId' };\r\ntype ProductId = string & { __brand: 'ProductId' };\r\n\r\nfunction createUserId(id: string): UserId {\r\n  return id as UserId;\r\nfunction createProductId(id: string): ProductId {\r\n  return id as ProductId;\r\n}\r\n\r\nconst userId = createUserId('123');\r\nconst productId = createProductId('456');\r\n\r\n// userId === productId; // Type error (even if same string value)\r\n// function getUser(id: UserId) { ... }\r\n// getUser(productId); // Error: Type 'ProductId' is not assignable to type 'UserId'\r\n\r\n// Using unique symbol (better approach)\r\ndeclare const UserIdBrand: unique symbol;\r\ntype UserId = string & { [UserIdBrand]: true };\r\n\r\ndeclare const ProductIdBrand: unique symbol;\r\ntype ProductId = string & { [ProductIdBrand]: true };\r\n\r\n// Practical: Money type\r\ndeclare const MoneyBrand: unique symbol;\r\ntype Money = number & { [MoneyBrand]: true };\r\n\r\nfunction createMoney(amount: number): Money {\r\n  if (amount < 0) throw new Error('Amount cannot be negative');\r\n  return amount as Money;\r\n}\r\n\r\nfunction addMoney(a: Money, b: Money): Money {\r\n  return (a + b) as Money;\r\n}\r\n\r\nconst salary = createMoney(5000);\r\nconst bonus = createMoney(1000);\r\nconst total = addMoney(salary, bonus); // OK\r\n// const invalid = addMoney(salary, 1000); // Error\r\n\r\n// Email type\r\ndeclare const EmailBrand: unique symbol;\r\ntype Email = string & { [EmailBrand]: true };\r\n\r\nfunction createEmail(email: string): Email {\r\n  if (!email.includes('@')) throw new Error('Invalid email');\r\n  return email as Email;\r\n}\r\n```",
    "number": 17
  },
  {
    "id": "typescript-18",
    "topic": "typescript",
    "title": "Explain `satisfies` Operator (TypeScript 4.9+)",
    "answer": "The `satisfies` operator ensures a value matches a type without changing the inferred type.\r\n\r\n```typescript\r\n// Without satisfies - loses specific types\r\nconst config: Record<string, string | number> = {\r\n  apiUrl: 'https://api.example.com',\r\n  timeout: 5000,\r\n  retries: 3\r\n};\r\n// config.apiUrl is string | number (too broad)\r\n\r\n// With satisfies - preserves specific types\r\nconst config2 = {\r\n  apiUrl: 'https://api.example.com',\r\n  timeout: 5000,\r\n  retries: 3\r\n} satisfies Record<string, string | number>;\r\n// config2.apiUrl is string (preserved)\r\n\r\n// Ensures type safety while preserving inference\r\ntype Theme = 'light' | 'dark';\r\ntype Config = {\r\n  theme: Theme;\r\n  apiUrl: string;\r\n};\r\n\r\nconst appConfig = {\r\n  theme: 'light',\r\n  apiUrl: 'https://api.example.com'\r\n} satisfies Config;\r\n// appConfig.theme is 'light' (not Theme union)\r\n\r\n// Error detection\r\nconst invalid = {\r\n  theme: 'blue', // Error: 'blue' not assignable to Theme\r\n  apiUrl: 123 // Error: number not assignable to string\r\n} satisfies Config;\r\n\r\n// React component props example\r\ntype ButtonProps = {\r\n  variant: 'primary' | 'secondary';\r\n  size: 'sm' | 'md' | 'lg';\r\n};\r\n\r\nconst buttonProps = {\r\n  variant: 'primary',\r\n  size: 'md'\r\n} satisfies ButtonProps;\r\n// buttonProps.variant is 'primary' (literal), not union\r\n```",
    "number": 18
  },
  {
    "id": "typescript-19",
    "topic": "typescript",
    "title": "What are Assertion Functions?",
    "answer": "Assertion functions narrow types and throw if conditions aren't met.\r\n\r\n```typescript\r\n// Assertion function\r\nfunction assertIsString(value: unknown): asserts value is string {\r\n  if (typeof value !== 'string') {\r\n    throw new Error('Value is not a string');\r\n  }\r\n}\r\n\r\nfunction process(value: unknown) {\r\n  assertIsString(value);\r\n  // TypeScript knows value is string here\r\n  return value.toUpperCase();\r\n}\r\n\r\n// Assertion with condition\r\nfunction assert(condition: unknown): asserts condition {\r\n  if (!condition) {\r\n    throw new Error('Assertion failed');\r\n  }\r\n}\r\n\r\nfunction divide(a: number, b: number): number {\r\n  assert(b !== 0); // TypeScript knows b !== 0 after this\r\n  return a / b;\r\n}\r\n\r\n// Assert non-null\r\nfunction assertNotNull<T>(value: T | null): asserts value is T {\r\n  if (value === null) {\r\n    throw new Error('Value is null');\r\n  }\r\n}\r\n\r\nfunction processUser(user: User | null) {\r\n  assertNotNull(user);\r\n  // TypeScript knows user is User here\r\n  return user.name;\r\n}\r\n\r\n// Assert array element type\r\nfunction assertIsArray<T>(\r\n  value: unknown,\r\n  check: (item: unknown) => item is T\r\n): asserts value is T[] {\r\n  if (!Array.isArray(value) || !value.every(check)) {\r\n    throw new Error('Value is not an array of expected type');\r\n  }\r\n}\r\n\r\nfunction isNumber(value: unknown): value is number {\r\n  return typeof value === 'number';\r\n}\r\n\r\nfunction processNumbers(values: unknown) {\r\n  assertIsArray(values, isNumber);\r\n  // TypeScript knows values is number[]\r\n  return values.reduce((a, b) => a + b, 0);\r\n}\r\n```",
    "number": 19
  },
  {
    "id": "typescript-20",
    "topic": "typescript",
    "title": "Explain Module Resolution and Path Mapping",
    "answer": "TypeScript resolves module imports using various strategies and path aliases.\r\n\r\n```typescript\r\n// tsconfig.json path mapping\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@/*\": [\"src/*\"],\r\n      \"@components/*\": [\"src/components/*\"],\r\n      \"@utils/*\": [\"src/utils/*\"]\r\n    }\r\n  }\r\n}\r\n\r\n// Usage\r\nimport { Button } from '@components/Button';\r\nimport { formatDate } from '@utils/date';\r\nimport { User } from '@/types/User';\r\n\r\n// Module resolution strategies\r\n// 1. \"node\" - Node.js style (default for most projects)\r\n// 2. \"classic\" - TypeScript classic (legacy)\r\n\r\n// Resolution order (node strategy):\r\n// 1. Check package.json \"types\" or \"typings\"\r\n// 2. Look for .d.ts files\r\n// 3. Look for .ts/.tsx files\r\n// 4. Check node_modules\r\n\r\n// Type-only imports\r\nimport type { User } from './types';\r\nimport { type User, type Post } from './types';\r\nimport type * as Types from './types';\r\n\r\n// Re-exporting\r\nexport { User, Post } from './types';\r\nexport type { UserType, PostType } from './types';\r\n\r\n// Namespace imports\r\nimport * as Utils from './utils';\r\nUtils.formatDate(new Date());\r\n```",
    "number": 20
  },
  {
    "id": "typescript-21",
    "topic": "typescript",
    "title": "What are Decorators and How Do They Work?",
    "answer": "Decorators are special declarations that can be attached to classes, methods, properties, etc. (experimental feature).\r\n\r\n```typescript\r\n// Enable decorators in tsconfig.json\r\n// \"experimentalDecorators\": true\r\n\r\n// Class decorator\r\nfunction Logger(target: Function) {\r\n  console.log('Class created:', target.name);\r\n}\r\n\r\n@Logger\r\nclass User {\r\n  name: string;\r\n  constructor(name: string) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\n// Method decorator\r\nfunction Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\r\n  const original = descriptor.value;\r\n  descriptor.value = function(...args: any[]) {\r\n    console.log(`Calling ${propertyKey} with`, args);\r\n    return original.apply(this, args);\r\n  };\r\n}\r\n\r\nclass Calculator {\r\n  @Log\r\n  add(a: number, b: number): number {\r\n    return a + b;\r\n  }\r\n}\r\n\r\n// Property decorator\r\nfunction ReadOnly(target: any, propertyKey: string) {\r\n  Object.defineProperty(target, propertyKey, {\r\n    writable: false\r\n  });\r\n}\r\n\r\nclass Product {\r\n  @ReadOnly\r\n  id: string = '123';\r\n}\r\n\r\n// Parameter decorator\r\nfunction Required(target: any, propertyKey: string, parameterIndex: number) {\r\n  // Metadata storage\r\n}\r\n\r\nclass Service {\r\n  create(@Required name: string) {\r\n    // Implementation\r\n  }\r\n}\r\n\r\n// Decorator factory\r\nfunction Log(prefix: string) {\r\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\r\n    const original = descriptor.value;\r\n    descriptor.value = function(...args: any[]) {\r\n      console.log(`[${prefix}] ${propertyKey}`, args);\r\n      return original.apply(this, args);\r\n    };\r\n  };\r\n}\r\n\r\nclass ApiService {\r\n  @Log('API')\r\n  fetchData(url: string) {\r\n    // Implementation\r\n  }\r\n}\r\n```",
    "number": 21
  },
  {
    "id": "typescript-22",
    "topic": "typescript",
    "title": "Explain Type Narrowing with Discriminated Unions",
    "answer": "Discriminated unions use a common property to narrow types safely.\r\n\r\n```typescript\r\n// Discriminated union\r\ntype Success = {\r\n  status: 'success';\r\n  data: string;\r\n};\r\n\r\ntype Error = {\r\n  status: 'error';\r\n  message: string;\r\n};\r\n\r\ntype Loading = {\r\n  status: 'loading';\r\n};\r\n\r\ntype Result = Success | Error | Loading;\r\n\r\nfunction handleResult(result: Result) {\r\n  switch (result.status) {\r\n    case 'success':\r\n      // TypeScript knows result is Success\r\n      console.log(result.data);\r\n      break;\r\n    case 'error':\r\n      // TypeScript knows result is Error\r\n      console.log(result.message);\r\n      break;\r\n    case 'loading':\r\n      // TypeScript knows result is Loading\r\n      console.log('Loading...');\r\n      break;\r\n    default:\r\n      const exhaustive: never = result; // Ensures all cases handled\r\n  }\r\n}\r\n\r\n// Multiple discriminators\r\ntype ApiResponse<T> =\r\n  | { success: true; data: T }\r\n  | { success: false; error: string };\r\n\r\nfunction handleResponse<T>(response: ApiResponse<T>) {\r\n  if (response.success) {\r\n    // TypeScript knows response.data exists\r\n    return response.data;\r\n  } else {\r\n    // TypeScript knows response.error exists\r\n    return response.error;\r\n  }\r\n}\r\n\r\n// Tagged union with multiple properties\r\ntype Event =\r\n  | { type: 'click'; x: number; y: number }\r\n  | { type: 'keypress'; key: string }\r\n  | { type: 'scroll'; position: number };\r\n\r\nfunction handleEvent(event: Event) {\r\n  switch (event.type) {\r\n    case 'click':\r\n      console.log(`Clicked at (${event.x}, ${event.y})`);\r\n      break;\r\n    case 'keypress':\r\n      console.log(`Key pressed: ${event.key}`);\r\n      break;\r\n    case 'scroll':\r\n      console.log(`Scrolled to ${event.position}`);\r\n      break;\r\n  }\r\n}\r\n```",
    "number": 22
  },
  {
    "id": "typescript-23",
    "topic": "typescript",
    "title": "What are Recursive Types?",
    "answer": "Recursive types reference themselves in their definition.\r\n\r\n```typescript\r\n// Recursive type\r\ntype JsonValue =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | JsonValue[]\r\n  | { [key: string]: JsonValue };\r\n\r\nconst json: JsonValue = {\r\n  name: 'John',\r\n  age: 30,\r\n  tags: ['developer', 'typescript'],\r\n  metadata: {\r\n    created: '2024-01-01',\r\n    nested: {\r\n      value: 123\r\n    }\r\n  }\r\n};\r\n\r\n// Tree structure\r\ntype TreeNode<T> = {\r\n  value: T;\r\n  children: TreeNode<T>[];\r\n};\r\n\r\nconst tree: TreeNode<string> = {\r\n  value: 'root',\r\n  children: [\r\n    {\r\n      value: 'child1',\r\n      children: []\r\n    },\r\n    {\r\n      value: 'child2',\r\n      children: [\r\n        { value: 'grandchild', children: [] }\r\n      ]\r\n    }\r\n  ]\r\n};\r\n\r\n// Linked list\r\ntype ListNode<T> = {\r\n  value: T;\r\n  next: ListNode<T> | null;\r\n};\r\n\r\nconst list: ListNode<number> = {\r\n  value: 1,\r\n  next: {\r\n    value: 2,\r\n    next: {\r\n      value: 3,\r\n      next: null\r\n    }\r\n  }\r\n};\r\n\r\n// Recursive utility type: DeepReadonly\r\ntype DeepReadonly<T> = {\r\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\r\n};\r\n\r\ntype User = {\r\n  name: string;\r\n  address: {\r\n    street: string;\r\n    city: string;\r\n  };\r\n};\r\n\r\ntype ReadonlyUser = DeepReadonly<User>;\r\n// All properties recursively readonly\r\n\r\n// Recursive Partial\r\ntype DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n```",
    "number": 23
  },
  {
    "id": "typescript-24",
    "topic": "typescript",
    "title": "Explain Type Predicates and Custom Type Guards",
    "answer": "Type predicates are functions that return type assertions, enabling custom type narrowing.\r\n\r\n```typescript\r\n// Type predicate function\r\nfunction isString(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\nfunction process(value: unknown) {\r\n  if (isString(value)) {\r\n    // TypeScript knows value is string\r\n    return value.toUpperCase();\r\n  }\r\n  // TypeScript knows value is not string\r\n  return String(value);\r\n}\r\n\r\n// Multiple type predicates\r\nfunction isNumber(value: unknown): value is number {\r\n  return typeof value === 'number' && !isNaN(value);\r\n}\r\n\r\nfunction isUser(value: unknown): value is User {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    'name' in value &&\r\n    'email' in value\r\n  );\r\n}\r\n\r\n// Array type guard\r\nfunction isStringArray(value: unknown): value is string[] {\r\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\r\n}\r\n\r\n// Discriminated union guard\r\ntype ApiResponse<T> = \r\n  | { success: true; data: T }\r\n  | { success: false; error: string };\r\n\r\nfunction isSuccess<T>(response: ApiResponse<T>): response is { success: true; data: T } {\r\n  return response.success === true;\r\n}\r\n\r\nfunction handleResponse<T>(response: ApiResponse<T>) {\r\n  if (isSuccess(response)) {\r\n    // TypeScript knows response is success type\r\n    return response.data;\r\n  }\r\n  // TypeScript knows response is error type\r\n  return response.error;\r\n}\r\n\r\n// Complex type guard\r\ninterface Admin {\r\n  role: 'admin';\r\n  permissions: string[];\r\n}\r\n\r\ninterface User {\r\n  role: 'user';\r\n  name: string;\r\n}\r\n\r\ntype Person = Admin | User;\r\n\r\nfunction isAdmin(person: Person): person is Admin {\r\n  return person.role === 'admin';\r\n}\r\n\r\nfunction checkAccess(person: Person) {\r\n  if (isAdmin(person)) {\r\n    // TypeScript knows person is Admin\r\n    return person.permissions;\r\n  }\r\n  // TypeScript knows person is User\r\n  return person.name;\r\n}\r\n```",
    "number": 24
  },
  {
    "id": "typescript-25",
    "topic": "typescript",
    "title": "Explain Advanced Generic Patterns",
    "answer": "Advanced generic patterns enable powerful type transformations and reusable type-safe code.\r\n\r\n```typescript\r\n// Constraint with keyof\r\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\r\n  return obj[key];\r\n}\r\n\r\nconst user = { name: 'John', age: 30 };\r\nconst name = getProperty(user, 'name'); // string\r\nconst age = getProperty(user, 'age'); // number\r\n\r\n// Conditional generic constraints\r\ntype NonFunctionPropertyNames<T> = {\r\n  [K in keyof T]: T[K] extends Function ? never : K;\r\n}[keyof T];\r\n\r\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\r\n\r\ninterface Example {\r\n  name: string;\r\n  age: number;\r\n  getName: () => string;\r\n}\r\n\r\ntype DataOnly = NonFunctionProperties<Example>; // { name: string; age: number; }\r\n\r\n// Higher-order generic functions\r\nfunction createGetter<T>() {\r\n  return function<K extends keyof T>(obj: T, key: K): T[K] {\r\n    return obj[key];\r\n  };\r\n}\r\n\r\nconst getUserProperty = createGetter<User>();\r\nconst name = getUserProperty(user, 'name');\r\n\r\n// Generic defaults\r\ninterface ApiResponse<T = any> {\r\n  data: T;\r\n  status: number;\r\n}\r\n\r\ntype StringResponse = ApiResponse<string>;\r\ntype DefaultResponse = ApiResponse; // T defaults to any\r\n\r\n// Mapped types with generics\r\ntype Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\r\n\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  age: number;\r\n}\r\n\r\ntype UserUpdate = Optional<User, 'id'>; // id required, others optional\r\n\r\n// Recursive generic\r\ntype DeepRequired<T> = {\r\n  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];\r\n};\r\n\r\n// Generic type extraction\r\ntype ExtractReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\r\n\r\ntype Fn = (a: number) => string;\r\ntype Return = ExtractReturnType<Fn>; // string\r\n\r\n// Flatten generic\r\ntype Flatten<T> = T extends (infer U)[] ? U : T;\r\ntype Nested = string[][];\r\ntype Flat = Flatten<Nested>; // string[]\r\n```",
    "number": 25
  }
]