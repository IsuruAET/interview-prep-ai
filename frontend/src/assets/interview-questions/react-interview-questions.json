[
  {
    "id": "react-1",
    "topic": "react",
    "title": "Explain React Components: Functional vs Class Components",
    "answer": "React components are reusable UI pieces. Functional components (with hooks) are now the standard, while class components are legacy.\r\n\r\n```typescript\r\n// Functional Component (Modern - Recommended)\r\nimport React from \"react\";\r\n\r\ninterface Props {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\nconst UserProfile: React.FC<Props> = ({ name, age }) => {\r\n  return (\r\n    <div>\r\n      <h1>{name}</h1>\r\n      <p>Age: {age}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Or without React.FC\r\nconst UserProfile = ({ name, age }: Props) => {\r\n  return (\r\n    <div>\r\n      <h1>{name}</h1>\r\n      <p>Age: {age}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Class Component (Legacy)\r\nclass UserProfileClass extends React.Component<Props> {\r\n  render() {\r\n    const { name, age } = this.props;\r\n    return (\r\n      <div>\r\n        <h1>{name}</h1>\r\n        <p>Age: {age}</p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// When to use:\r\n// - Functional components: Always (modern React)\r\n// - Class components: Only for legacy codebases or error boundaries\r\n```",
    "number": 1
  },
  {
    "id": "react-2",
    "topic": "react",
    "title": "Explain useState Hook and Its Behavior",
    "answer": "`useState` manages component state. It returns the current state and a setter function.\r\n\r\n```typescript\r\nimport { useState } from \"react\";\r\n\r\n// Basic usage\r\nconst Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <button onClick={() => setCount((prev) => prev + 1)}>\r\n        Increment (Functional)\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Object state\r\nconst UserForm = () => {\r\n  const [user, setUser] = useState({\r\n    name: \"\",\r\n    email: \"\",\r\n  });\r\n\r\n  const updateName = (name: string) => {\r\n    setUser((prev) => ({ ...prev, name })); // Preserve other fields\r\n  };\r\n\r\n  return (\r\n    <input value={user.name} onChange={(e) => updateName(e.target.value)} />\r\n  );\r\n};\r\n\r\n// Lazy initialization\r\nconst ExpensiveComponent = () => {\r\n  // Only runs once on mount\r\n  const [data, setData] = useState(() => {\r\n    return expensiveCalculation();\r\n  });\r\n\r\n  return <div>{data}</div>;\r\n};\r\n\r\n// Multiple state variables\r\nconst Form = () => {\r\n  const [name, setName] = useState(\"\");\r\n  const [email, setEmail] = useState(\"\");\r\n  const [age, setAge] = useState(0);\r\n\r\n  // Better: Use single state object for related data\r\n  const [formData, setFormData] = useState({\r\n    name: \"\",\r\n    email: \"\",\r\n    age: 0,\r\n  });\r\n};\r\n```",
    "number": 2
  },
  {
    "id": "react-3",
    "topic": "react",
    "title": "Explain useEffect Hook and Dependency Array",
    "answer": "`useEffect` handles side effects (API calls, subscriptions, DOM manipulation).\r\n\r\n```typescript\r\nimport { useEffect, useState } from \"react\";\r\n\r\n// Run on every render (no dependency array)\r\nconst Component1 = () => {\r\n  useEffect(() => {\r\n    console.log(\"Runs on every render\");\r\n  });\r\n};\r\n\r\n// Run only on mount (empty dependency array)\r\nconst Component2 = () => {\r\n  useEffect(() => {\r\n    console.log(\"Runs once on mount\");\r\n    // Cleanup function\r\n    return () => {\r\n      console.log(\"Cleanup on unmount\");\r\n    };\r\n  }, []);\r\n};\r\n\r\n// Run when dependencies change\r\nconst UserProfile = ({ userId }: { userId: number }) => {\r\n  const [user, setUser] = useState(null);\r\n\r\n  useEffect(() => {\r\n    fetchUser(userId).then(setUser);\r\n  }, [userId]); // Re-runs when userId changes\r\n\r\n  return <div>{user?.name}</div>;\r\n};\r\n\r\n// Cleanup example: Subscription\r\nconst ChatRoom = ({ roomId }: { roomId: string }) => {\r\n  useEffect(() => {\r\n    const subscription = subscribe(roomId);\r\n\r\n    return () => {\r\n      subscription.unsubscribe(); // Cleanup on unmount or roomId change\r\n    };\r\n  }, [roomId]);\r\n};\r\n\r\n// Multiple effects\r\nconst Component = () => {\r\n  useEffect(() => {\r\n    // Effect 1\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Effect 2\r\n  }, []);\r\n};\r\n\r\n// Async operations in useEffect\r\nuseEffect(() => {\r\n  let cancelled = false;\r\n\r\n  async function fetchData() {\r\n    const data = await api.getData();\r\n    if (!cancelled) {\r\n      setData(data);\r\n    }\r\n  }\r\n\r\n  fetchData();\r\n\r\n  return () => {\r\n    cancelled = true;\r\n  };\r\n}, []);\r\n```",
    "number": 3
  },
  {
    "id": "react-4",
    "topic": "react",
    "title": "Explain useCallback and useMemo Hooks",
    "answer": "`useCallback` memoizes functions, `useMemo` memoizes computed values to prevent unnecessary recalculations.\r\n\r\n```typescript\r\nimport { useCallback, useMemo, useState } from \"react\";\r\n\r\n// useCallback - Memoize functions\r\nconst Parent = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState(\"\");\r\n\r\n  // Without useCallback: New function on every render\r\n  const handleClick = () => {\r\n    console.log(\"Clicked\");\r\n  };\r\n\r\n  // With useCallback: Same function reference\r\n  const memoizedHandleClick = useCallback(() => {\r\n    console.log(\"Clicked\");\r\n  }, []); // Empty deps = never changes\r\n\r\n  // With dependencies\r\n  const handleSubmit = useCallback(\r\n    (value: string) => {\r\n      console.log(name, value);\r\n    },\r\n    [name]\r\n  ); // Recreates when name changes\r\n\r\n  return <Child onClick={memoizedHandleClick} />;\r\n};\r\n\r\n// useMemo - Memoize computed values\r\nconst ExpensiveComponent = ({ items }: { items: number[] }) => {\r\n  const [filter, setFilter] = useState(\"\");\r\n\r\n  // Expensive calculation - only runs when items or filter changes\r\n  const filteredItems = useMemo(() => {\r\n    return items.filter((item) => item.toString().includes(filter));\r\n  }, [items, filter]);\r\n\r\n  // Another example: Derived state\r\n  const sortedItems = useMemo(() => {\r\n    return [...items].sort((a, b) => a - b);\r\n  }, [items]);\r\n\r\n  return (\r\n    <div>\r\n      {filteredItems.map((item) => (\r\n        <div key={item}>{item}</div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// When NOT to use\r\nconst SimpleComponent = ({ value }: { value: number }) => {\r\n  // Don't memoize simple calculations\r\n  const doubled = value * 2; // OK - simple calculation\r\n\r\n  // Don't memoize primitives\r\n  const memoized = useMemo(() => value * 2, [value]); // Unnecessary\r\n};\r\n```",
    "number": 4
  },
  {
    "id": "react-5",
    "topic": "react",
    "title": "Explain React.memo and When to Use It",
    "answer": "`React.memo` prevents re-renders when props haven't changed (shallow comparison).\r\n\r\n```typescript\r\nimport { memo } from \"react\";\r\n\r\n// Without memo: Re-renders on every parent render\r\nconst UserCard = ({ name, email }: { name: string; email: string }) => {\r\n  console.log(\"UserCard rendered\");\r\n  return (\r\n    <div>\r\n      <h3>{name}</h3>\r\n      <p>{email}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// With memo: Only re-renders when props change\r\nconst MemoizedUserCard = memo(\r\n  ({ name, email }: { name: string; email: string }) => {\r\n    console.log(\"MemoizedUserCard rendered\");\r\n    return (\r\n      <div>\r\n        <h3>{name}</h3>\r\n        <p>{email}</p>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\n// Custom comparison function\r\nconst CustomMemoized = memo(\r\n  ({ user }: { user: User }) => {\r\n    return <div>{user.name}</div>;\r\n  },\r\n  (prevProps, nextProps) => {\r\n    // Return true if props are equal (skip render)\r\n    return prevProps.user.id === nextProps.user.id;\r\n  }\r\n);\r\n\r\n// Parent component\r\nconst UserList = () => {\r\n  const [users, setUsers] = useState<User[]>([]);\r\n  const [filter, setFilter] = useState(\"\");\r\n\r\n  // MemoizedUserCard won't re-render when filter changes\r\n  return (\r\n    <div>\r\n      <input value={filter} onChange={(e) => setFilter(e.target.value)} />\r\n      {users.map((user) => (\r\n        <MemoizedUserCard key={user.id} name={user.name} email={user.email} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// When to use:\r\n// - Component receives same props frequently\r\n// - Component is expensive to render\r\n// - Component is in a list with many items\r\n```",
    "number": 5
  },
  {
    "id": "react-6",
    "topic": "react",
    "title": "Explain useContext Hook and Context API",
    "answer": "Context provides a way to pass data through the component tree without prop drilling.\r\n\r\n```typescript\r\nimport { createContext, useContext, useState, ReactNode } from \"react\";\r\n\r\n// Create context\r\ninterface ThemeContextType {\r\n  theme: \"light\" | \"dark\";\r\n  toggleTheme: () => void;\r\n}\r\n\r\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\r\n\r\n// Provider component\r\nconst ThemeProvider = ({ children }: { children: ReactNode }) => {\r\n  const [theme, setTheme] = useState<\"light\" | \"dark\">(\"light\");\r\n\r\n  const toggleTheme = () => {\r\n    setTheme((prev) => (prev === \"light\" ? \"dark\" : \"light\"));\r\n  };\r\n\r\n  return (\r\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook with error handling\r\nconst useTheme = () => {\r\n  const context = useContext(ThemeContext);\r\n  if (!context) {\r\n    throw new Error(\"useTheme must be used within ThemeProvider\");\r\n  }\r\n  return context;\r\n};\r\n\r\n// Consumer component\r\nconst ThemedButton = () => {\r\n  const { theme, toggleTheme } = useTheme();\r\n\r\n  return (\r\n    <button\r\n      onClick={toggleTheme}\r\n      style={{\r\n        backgroundColor: theme === \"dark\" ? \"#333\" : \"#fff\",\r\n        color: theme === \"dark\" ? \"#fff\" : \"#333\",\r\n      }}\r\n    >\r\n      Current theme: {theme}\r\n    </button>\r\n  );\r\n};\r\n\r\n// App setup\r\nconst App = () => {\r\n  return (\r\n    <ThemeProvider>\r\n      <ThemedButton />\r\n    </ThemeProvider>\r\n  );\r\n};\r\n\r\n// Multiple contexts\r\nconst UserContext = createContext<User | null>(null);\r\nconst SettingsContext = createContext<Settings | null>(null);\r\n\r\nconst App = () => {\r\n  return (\r\n    <UserContext.Provider value={user}>\r\n      <SettingsContext.Provider value={settings}>\r\n        <Components />\r\n      </SettingsContext.Provider>\r\n    </UserContext.Provider>\r\n  );\r\n};\r\n```",
    "number": 6
  },
  {
    "id": "react-7",
    "topic": "react",
    "title": "Explain useRef Hook and Its Use Cases",
    "answer": "`useRef` returns a mutable ref object that persists across renders without causing re-renders.\r\n\r\n```typescript\r\nimport { useRef, useEffect } from \"react\";\r\n\r\n// DOM reference\r\nconst InputFocus = () => {\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  useEffect(() => {\r\n    inputRef.current?.focus();\r\n  }, []);\r\n\r\n  return <input ref={inputRef} />;\r\n};\r\n\r\n// Storing mutable values (doesn't trigger re-render)\r\nconst Timer = () => {\r\n  const [count, setCount] = useState(0);\r\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const startTimer = () => {\r\n    intervalRef.current = setInterval(() => {\r\n      setCount((prev) => prev + 1);\r\n    }, 1000);\r\n  };\r\n\r\n  const stopTimer = () => {\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>{count}</p>\r\n      <button onClick={startTimer}>Start</button>\r\n      <button onClick={stopTimer}>Stop</button>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Previous value tracking\r\nconst usePrevious = <T>(value: T): T | undefined => {\r\n  const ref = useRef<T>();\r\n\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  });\r\n\r\n  return ref.current;\r\n};\r\n\r\nconst Component = ({ count }: { count: number }) => {\r\n  const prevCount = usePrevious(count);\r\n\r\n  return (\r\n    <div>\r\n      <p>Current: {count}</p>\r\n      <p>Previous: {prevCount}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Imperative handle (exposing methods to parent)\r\nconst FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    focus: () => inputRef.current?.focus(),\r\n    blur: () => inputRef.current?.blur(),\r\n    getValue: () => inputRef.current?.value,\r\n  }));\r\n\r\n  return <input ref={inputRef} />;\r\n});\r\n```",
    "number": 7
  },
  {
    "id": "react-8",
    "topic": "react",
    "title": "Explain Custom Hooks",
    "answer": "Custom hooks extract component logic into reusable functions.\r\n\r\n```typescript\r\nimport { useState, useEffect } from \"react\";\r\n\r\n// Custom hook: API data fetching\r\nconst useFetch = <T>(url: string) => {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n\r\n    const fetchData = async () => {\r\n      try {\r\n        setLoading(true);\r\n        const response = await fetch(url);\r\n        const result = await response.json();\r\n\r\n        if (!cancelled) {\r\n          setData(result);\r\n          setError(null);\r\n        }\r\n      } catch (err) {\r\n        if (!cancelled) {\r\n          setError(err as Error);\r\n        }\r\n      } finally {\r\n        if (!cancelled) {\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    return () => {\r\n      cancelled = true;\r\n    };\r\n  }, [url]);\r\n\r\n  return { data, loading, error };\r\n};\r\n\r\n// Usage\r\nconst UserProfile = ({ userId }: { userId: number }) => {\r\n  const { data: user, loading, error } = useFetch<User>(`/api/users/${userId}`);\r\n\r\n  if (loading) return <div>Loading...</div>;\r\n  if (error) return <div>Error: {error.message}</div>;\r\n  if (!user) return null;\r\n\r\n  return <div>{user.name}</div>;\r\n};\r\n\r\n// Custom hook: Local storage\r\nconst useLocalStorage = <T>(key: string, initialValue: T) => {\r\n  const [storedValue, setStoredValue] = useState<T>(() => {\r\n    try {\r\n      const item = window.localStorage.getItem(key);\r\n      return item ? JSON.parse(item) : initialValue;\r\n    } catch {\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  const setValue = (value: T | ((val: T) => T)) => {\r\n    try {\r\n      const valueToStore =\r\n        value instanceof Function ? value(storedValue) : value;\r\n      setStoredValue(valueToStore);\r\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  return [storedValue, setValue] as const;\r\n};\r\n\r\n// Custom hook: Debounce\r\nconst useDebounce = <T>(value: T, delay: number): T => {\r\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n\r\n    return () => {\r\n      clearTimeout(handler);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n};\r\n\r\n// Usage\r\nconst SearchInput = () => {\r\n  const [searchTerm, setSearchTerm] = useState(\"\");\r\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\r\n\r\n  useEffect(() => {\r\n    // API call with debounced value\r\n    searchAPI(debouncedSearchTerm);\r\n  }, [debouncedSearchTerm]);\r\n\r\n  return (\r\n    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />\r\n  );\r\n};\r\n```",
    "number": 8
  },
  {
    "id": "react-9",
    "topic": "react",
    "title": "Explain React Router and Navigation",
    "answer": "React Router enables client-side routing and navigation in React applications.\r\n\r\n```typescript\r\nimport { BrowserRouter, Routes, Route, Link, useParams, useNavigate } from 'react-router-dom';\r\n\r\n// Basic routing setup\r\nconst App = () => {\r\n  return (\r\n    <BrowserRouter>\r\n      <nav>\r\n        <Link to=\"/\">Home</Link>\r\n        <Link to=\"/about\">About</Link>\r\n        <Link to=\"/users\">Users</Link>\r\n      </nav>\r\n\r\n      <Routes>\r\n        <Route path=\"/\" element={<Home />} />\r\n        <Route path=\"/about\" element={<About />} />\r\n        <Route path=\"/users\" element={<Users />} />\r\n        <Route path=\"/users/:id\" element={<UserDetail /> />\r\n        <Route path=\"*\" element={<NotFound />} /> {/* 404 */}\r\n      </Routes>\r\n    </BrowserRouter>\r\n  );\r\n};\r\n\r\n// Dynamic routes with useParams\r\nconst UserDetail = () => {\r\n  const { id } = useParams<{ id: string }>();\r\n  const { data: user } = useFetch<User>(`/api/users/${id}`);\r\n\r\n  return <div>User: {user?.name}</div>;\r\n};\r\n\r\n// Programmatic navigation\r\nconst Login = () => {\r\n  const navigate = useNavigate();\r\n\r\n  const handleLogin = async () => {\r\n    await login();\r\n    navigate('/dashboard'); // Navigate programmatically\r\n  };\r\n\r\n  return <button onClick={handleLogin}>Login</button>;\r\n};\r\n\r\n// Protected routes\r\nconst ProtectedRoute = ({ children }: { children: ReactNode }) => {\r\n  const { user } = useAuth();\r\n\r\n  if (!user) {\r\n    return <Navigate to=\"/login\" replace />;\r\n  }\r\n\r\n  return <>{children}</>;\r\n};\r\n\r\n// Nested routes\r\nconst App = () => {\r\n  return (\r\n    <Routes>\r\n      <Route path=\"/dashboard\" element={<Dashboard />}>\r\n        <Route path=\"profile\" element={<Profile />} />\r\n        <Route path=\"settings\" element={<Settings />} />\r\n      </Route>\r\n    </Routes>\r\n  );\r\n};\r\n\r\nconst Dashboard = () => {\r\n  return (\r\n    <div>\r\n      <Outlet /> {/* Renders nested routes */}\r\n    </div>\r\n  );\r\n};\r\n```",
    "number": 9
  },
  {
    "id": "react-10",
    "topic": "react",
    "title": "Explain Error Boundaries",
    "answer": "Error boundaries catch JavaScript errors in child components and display fallback UI.\r\n\r\n```typescript\r\nimport { Component, ErrorInfo, ReactNode } from \"react\";\r\n\r\ninterface Props {\r\n  children: ReactNode;\r\n  fallback?: ReactNode;\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nclass ErrorBoundary extends Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): State {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    console.error(\"Error caught by boundary:\", error, errorInfo);\r\n    // Log to error reporting service\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        this.props.fallback || (\r\n          <div>\r\n            <h2>Something went wrong.</h2>\r\n            <p>{this.state.error?.message}</p>\r\n            <button\r\n              onClick={() => this.setState({ hasError: false, error: null })}\r\n            >\r\n              Try again\r\n            </button>\r\n          </div>\r\n        )\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Usage\r\nconst App = () => {\r\n  return (\r\n    <ErrorBoundary fallback={<ErrorFallback />}>\r\n      <ComponentThatMightError />\r\n    </ErrorBoundary>\r\n  );\r\n};\r\n\r\n// Hook-based error boundary (using react-error-boundary library)\r\nimport { ErrorBoundary } from \"react-error-boundary\";\r\n\r\nfunction ErrorFallback({ error, resetErrorBoundary }: any) {\r\n  return (\r\n    <div role=\"alert\">\r\n      <p>Something went wrong:</p>\r\n      <pre>{error.message}</pre>\r\n      <button onClick={resetErrorBoundary}>Try again</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst App = () => {\r\n  return (\r\n    <ErrorBoundary\r\n      FallbackComponent={ErrorFallback}\r\n      onError={(error, info) => {\r\n        // Log error\r\n      }}\r\n      onReset={() => {\r\n        // Reset app state\r\n      }}\r\n    >\r\n      <App />\r\n    </ErrorBoundary>\r\n  );\r\n};\r\n```",
    "number": 10
  },
  {
    "id": "react-11",
    "topic": "react",
    "title": "Explain React Portals",
    "answer": "Portals render children into a DOM node outside the parent component hierarchy.\r\n\r\n```typescript\r\nimport { createPortal } from \"react-dom\";\r\n\r\n// Modal component using portal\r\nconst Modal = ({ isOpen, onClose, children }: ModalProps) => {\r\n  if (!isOpen) return null;\r\n\r\n  return createPortal(\r\n    <div className=\"modal-overlay\" onClick={onClose}>\r\n      <div className=\"modal-content\" onClick={(e) => e.stopPropagation()}>\r\n        {children}\r\n        <button onClick={onClose}>Close</button>\r\n      </div>\r\n    </div>,\r\n    document.body // Render to body instead of parent\r\n  );\r\n};\r\n\r\n// Tooltip using portal\r\nconst Tooltip = ({ children, text }: TooltipProps) => {\r\n  const [isVisible, setIsVisible] = useState(false);\r\n  const [position, setPosition] = useState({ x: 0, y: 0 });\r\n  const ref = useRef<HTMLDivElement>(null);\r\n\r\n  const handleMouseEnter = () => {\r\n    if (ref.current) {\r\n      const rect = ref.current.getBoundingClientRect();\r\n      setPosition({\r\n        x: rect.left + rect.width / 2,\r\n        y: rect.top - 10,\r\n      });\r\n      setIsVisible(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        ref={ref}\r\n        onMouseEnter={handleMouseEnter}\r\n        onMouseLeave={() => setIsVisible(false)}\r\n      >\r\n        {children}\r\n      </div>\r\n      {isVisible &&\r\n        createPortal(\r\n          <div\r\n            className=\"tooltip\"\r\n            style={{\r\n              position: \"fixed\",\r\n              left: position.x,\r\n              top: position.y,\r\n              zIndex: 1000,\r\n            }}\r\n          >\r\n            {text}\r\n          </div>,\r\n          document.body\r\n        )}\r\n    </>\r\n  );\r\n};\r\n\r\n// Toast notifications\r\nconst ToastContainer = () => {\r\n  return createPortal(\r\n    <div className=\"toast-container\">{/* Toasts rendered here */}</div>,\r\n    document.getElementById(\"toast-root\")!\r\n  );\r\n};\r\n```",
    "number": 11
  },
  {
    "id": "react-12",
    "topic": "react",
    "title": "Explain Code Splitting and Lazy Loading",
    "answer": "Code splitting loads components only when needed, reducing initial bundle size.\r\n\r\n```typescript\r\nimport { lazy, Suspense } from \"react\";\r\n\r\n// Lazy load component\r\nconst LazyComponent = lazy(() => import(\"./HeavyComponent\"));\r\n\r\n// With default export\r\nconst Dashboard = lazy(() => import(\"./Dashboard\"));\r\n\r\n// With named export\r\nconst UserProfile = lazy(() =>\r\n  import(\"./UserProfile\").then((module) => ({\r\n    default: module.UserProfile,\r\n  }))\r\n);\r\n\r\n// Usage with Suspense\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <LazyComponent />\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// Route-based code splitting\r\nimport { Routes, Route } from \"react-router-dom\";\r\n\r\nconst Home = lazy(() => import(\"./pages/Home\"));\r\nconst About = lazy(() => import(\"./pages/About\"));\r\nconst Contact = lazy(() => import(\"./pages/Contact\"));\r\n\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<PageLoader />}>\r\n      <Routes>\r\n        <Route path=\"/\" element={<Home />} />\r\n        <Route path=\"/about\" element={<About />} />\r\n        <Route path=\"/contact\" element={<Contact />} />\r\n      </Routes>\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// Multiple lazy components\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <Routes>\r\n        <Route\r\n          path=\"/dashboard/*\"\r\n          element={\r\n            <Suspense fallback={<DashboardLoader />}>\r\n              <Dashboard />\r\n            </Suspense>\r\n          }\r\n        />\r\n      </Routes>\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// Preloading\r\nconst preloadComponent = () => {\r\n  const component = import(\"./HeavyComponent\");\r\n  return component;\r\n};\r\n\r\nconst Button = () => {\r\n  const handleMouseEnter = () => {\r\n    preloadComponent(); // Preload on hover\r\n  };\r\n\r\n  return <button onMouseEnter={handleMouseEnter}>Click me</button>;\r\n};\r\n```",
    "number": 12
  },
  {
    "id": "react-13",
    "topic": "react",
    "title": "Explain React Performance Optimization Techniques",
    "answer": "Multiple techniques optimize React app performance.\r\n\r\n```typescript\r\n// 1. React.memo for component memoization\r\nconst ExpensiveComponent = memo(({ data }: Props) => {\r\n  return <div>{/* Expensive rendering */}</div>;\r\n});\r\n\r\n// 2. useMemo for expensive calculations\r\nconst Component = ({ items }: { items: Item[] }) => {\r\n  const sortedItems = useMemo(() => {\r\n    return items.sort((a, b) => a.value - b.value);\r\n  }, [items]);\r\n\r\n  return (\r\n    <div>\r\n      {sortedItems.map((item) => (\r\n        <Item key={item.id} {...item} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// 3. useCallback for function memoization\r\nconst Parent = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const handleClick = useCallback(() => {\r\n    console.log(\"Clicked\");\r\n  }, []);\r\n\r\n  return <Child onClick={handleClick} />;\r\n};\r\n\r\n// 4. Virtualization for long lists\r\nimport { FixedSizeList } from \"react-window\";\r\n\r\nconst VirtualizedList = ({ items }: { items: Item[] }) => {\r\n  return (\r\n    <FixedSizeList\r\n      height={600}\r\n      itemCount={items.length}\r\n      itemSize={50}\r\n      width=\"100%\"\r\n    >\r\n      {({ index, style }) => <div style={style}>{items[index].name}</div>}\r\n    </FixedSizeList>\r\n  );\r\n};\r\n\r\n// 5. Image lazy loading\r\nconst LazyImage = ({ src, alt }: ImageProps) => {\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const imgRef = useRef<HTMLImageElement>(null);\r\n\r\n  useEffect(() => {\r\n    const observer = new IntersectionObserver(([entry]) => {\r\n      if (entry.isIntersecting) {\r\n        setIsLoaded(true);\r\n        observer.disconnect();\r\n      }\r\n    });\r\n\r\n    if (imgRef.current) {\r\n      observer.observe(imgRef.current);\r\n    }\r\n\r\n    return () => observer.disconnect();\r\n  }, []);\r\n\r\n  return (\r\n    <img\r\n      ref={imgRef}\r\n      src={isLoaded ? src : undefined}\r\n      alt={alt}\r\n      loading=\"lazy\"\r\n    />\r\n  );\r\n};\r\n\r\n// 6. Debouncing expensive operations\r\nconst SearchInput = () => {\r\n  const [query, setQuery] = useState(\"\");\r\n  const debouncedQuery = useDebounce(query, 300);\r\n\r\n  useEffect(() => {\r\n    // Expensive search operation\r\n    performSearch(debouncedQuery);\r\n  }, [debouncedQuery]);\r\n\r\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\r\n};\r\n```",
    "number": 13
  },
  {
    "id": "react-14",
    "topic": "react",
    "title": "Explain Controlled vs Uncontrolled Components",
    "answer": "Controlled components use React state, uncontrolled components use DOM refs.\r\n\r\n```typescript\r\n// Controlled component\r\nconst ControlledInput = () => {\r\n  const [value, setValue] = useState(\"\");\r\n\r\n  return <input value={value} onChange={(e) => setValue(e.target.value)} />;\r\n};\r\n\r\n// Controlled form\r\nconst ControlledForm = () => {\r\n  const [formData, setFormData] = useState({\r\n    name: \"\",\r\n    email: \"\",\r\n    age: \"\",\r\n  });\r\n\r\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    setFormData((prev) => ({\r\n      ...prev,\r\n      [e.target.name]: e.target.value,\r\n    }));\r\n  };\r\n\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    console.log(formData);\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input name=\"name\" value={formData.name} onChange={handleChange} />\r\n      <input name=\"email\" value={formData.email} onChange={handleChange} />\r\n      <input name=\"age\" value={formData.age} onChange={handleChange} />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  );\r\n};\r\n\r\n// Uncontrolled component\r\nconst UncontrolledInput = () => {\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const handleSubmit = () => {\r\n    console.log(inputRef.current?.value);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <input ref={inputRef} defaultValue=\"initial\" />\r\n      <button onClick={handleSubmit}>Submit</button>\r\n    </>\r\n  );\r\n};\r\n\r\n// Uncontrolled form\r\nconst UncontrolledForm = () => {\r\n  const formRef = useRef<HTMLFormElement>(null);\r\n\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    const formData = new FormData(formRef.current!);\r\n    const data = Object.fromEntries(formData);\r\n    console.log(data);\r\n  };\r\n\r\n  return (\r\n    <form ref={formRef} onSubmit={handleSubmit}>\r\n      <input name=\"name\" defaultValue=\"\" />\r\n      <input name=\"email\" defaultValue=\"\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  );\r\n};\r\n\r\n// When to use:\r\n// Controlled: Need validation, conditional rendering, form state management\r\n// Uncontrolled: Simple forms, file inputs, third-party integrations\r\n```",
    "number": 14
  },
  {
    "id": "react-15",
    "topic": "react",
    "title": "Explain React State Management Patterns",
    "answer": "Various patterns manage state in React applications.\r\n\r\n```typescript\r\n// 1. Local state (useState)\r\nconst Component = () => {\r\n  const [count, setCount] = useState(0);\r\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\r\n};\r\n\r\n// 2. Lifted state (sharing between siblings)\r\nconst Parent = () => {\r\n  const [sharedState, setSharedState] = useState(\"\");\r\n\r\n  return (\r\n    <>\r\n      <ChildA value={sharedState} onChange={setSharedState} />\r\n      <ChildB value={sharedState} />\r\n    </>\r\n  );\r\n};\r\n\r\n// 3. Context API (global state)\r\nconst StateContext = createContext<{\r\n  state: AppState;\r\n  setState: (state: AppState) => void;\r\n} | null>(null);\r\n\r\nconst App = () => {\r\n  const [state, setState] = useState<AppState>(initialState);\r\n\r\n  return (\r\n    <StateContext.Provider value={{ state, setState }}>\r\n      <Components />\r\n    </StateContext.Provider>\r\n  );\r\n};\r\n\r\n// 4. useReducer (complex state logic)\r\ntype Action = { type: \"increment\" } | { type: \"decrement\" } | { type: \"reset\" };\r\n\r\nconst reducer = (state: number, action: Action): number => {\r\n  switch (action.type) {\r\n    case \"increment\":\r\n      return state + 1;\r\n    case \"decrement\":\r\n      return state - 1;\r\n    case \"reset\":\r\n      return 0;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst Counter = () => {\r\n  const [count, dispatch] = useReducer(reducer, 0);\r\n\r\n  return (\r\n    <div>\r\n      <p>{count}</p>\r\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\r\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\r\n      <button onClick={() => dispatch({ type: \"reset\" })}>Reset</button>\r\n    </div>\r\n  );\r\n};\r\n\r\n// 5. Custom hook for state management\r\nconst useAppState = () => {\r\n  const [state, setState] = useState(initialState);\r\n\r\n  const updateUser = (user: User) => {\r\n    setState((prev) => ({ ...prev, user }));\r\n  };\r\n\r\n  const updateSettings = (settings: Settings) => {\r\n    setState((prev) => ({ ...prev, settings }));\r\n  };\r\n\r\n  return { state, updateUser, updateSettings };\r\n};\r\n\r\n// 6. External state management (Zustand example)\r\nimport create from \"zustand\";\r\n\r\ninterface Store {\r\n  count: number;\r\n  increment: () => void;\r\n  decrement: () => void;\r\n}\r\n\r\nconst useStore = create<Store>((set) => ({\r\n  count: 0,\r\n  increment: () => set((state) => ({ count: state.count + 1 })),\r\n  decrement: () => set((state) => ({ count: state.count - 1 })),\r\n}));\r\n\r\nconst Component = () => {\r\n  const { count, increment, decrement } = useStore();\r\n  return (\r\n    <div>\r\n      <p>{count}</p>\r\n      <button onClick={increment}>+</button>\r\n      <button onClick={decrement}>-</button>\r\n    </div>\r\n  );\r\n};\r\n```",
    "number": 15
  },
  {
    "id": "react-16",
    "topic": "react",
    "title": "Explain useReducer Hook",
    "answer": "`useReducer` manages complex state logic with actions and reducers.\r\n\r\n```typescript\r\nimport { useReducer } from \"react\";\r\n\r\n// Basic reducer\r\ntype State = { count: number };\r\ntype Action =\r\n  | { type: \"increment\" }\r\n  | { type: \"decrement\" }\r\n  | { type: \"reset\" }\r\n  | { type: \"set\"; payload: number };\r\n\r\nconst reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"increment\":\r\n      return { count: state.count + 1 };\r\n    case \"decrement\":\r\n      return { count: state.count - 1 };\r\n    case \"reset\":\r\n      return { count: 0 };\r\n    case \"set\":\r\n      return { count: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst Counter = () => {\r\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {state.count}</p>\r\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\r\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\r\n      <button onClick={() => dispatch({ type: \"reset\" })}>Reset</button>\r\n      <button onClick={() => dispatch({ type: \"set\", payload: 10 })}>\r\n        Set to 10\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Complex state with useReducer\r\ninterface TodoState {\r\n  todos: Todo[];\r\n  filter: \"all\" | \"active\" | \"completed\";\r\n  searchTerm: string;\r\n}\r\n\r\ntype TodoAction =\r\n  | { type: \"ADD_TODO\"; payload: Todo }\r\n  | { type: \"TOGGLE_TODO\"; payload: number }\r\n  | { type: \"DELETE_TODO\"; payload: number }\r\n  | { type: \"SET_FILTER\"; payload: \"all\" | \"active\" | \"completed\" }\r\n  | { type: \"SET_SEARCH\"; payload: string };\r\n\r\nconst todoReducer = (state: TodoState, action: TodoAction): TodoState => {\r\n  switch (action.type) {\r\n    case \"ADD_TODO\":\r\n      return { ...state, todos: [...state.todos, action.payload] };\r\n    case \"TOGGLE_TODO\":\r\n      return {\r\n        ...state,\r\n        todos: state.todos.map((todo) =>\r\n          todo.id === action.payload\r\n            ? { ...todo, completed: !todo.completed }\r\n            : todo\r\n        ),\r\n      };\r\n    case \"DELETE_TODO\":\r\n      return {\r\n        ...state,\r\n        todos: state.todos.filter((todo) => todo.id !== action.payload),\r\n      };\r\n    case \"SET_FILTER\":\r\n      return { ...state, filter: action.payload };\r\n    case \"SET_SEARCH\":\r\n      return { ...state, searchTerm: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst TodoApp = () => {\r\n  const [state, dispatch] = useReducer(todoReducer, {\r\n    todos: [],\r\n    filter: \"all\",\r\n    searchTerm: \"\",\r\n  });\r\n\r\n  const filteredTodos = state.todos\r\n    .filter((todo) => {\r\n      if (state.filter === \"active\") return !todo.completed;\r\n      if (state.filter === \"completed\") return todo.completed;\r\n      return true;\r\n    })\r\n    .filter((todo) =>\r\n      todo.text.toLowerCase().includes(state.searchTerm.toLowerCase())\r\n    );\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        value={state.searchTerm}\r\n        onChange={(e) =>\r\n          dispatch({ type: \"SET_SEARCH\", payload: e.target.value })\r\n        }\r\n      />\r\n      {/* Render todos */}\r\n    </div>\r\n  );\r\n};\r\n\r\n// Lazy initialization\r\nconst init = (initialCount: number) => ({ count: initialCount });\r\n\r\nconst Counter = ({ initialCount }: { initialCount: number }) => {\r\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\r\n  // ...\r\n};\r\n```",
    "number": 16
  },
  {
    "id": "react-17",
    "topic": "react",
    "title": "Explain React Hooks Rules and Best Practices",
    "answer": "Hooks have rules that must be followed for correct behavior.\r\n\r\n```typescript\r\n// Rules:\r\n// 1. Only call hooks at the top level (not in loops, conditions, nested functions)\r\n// 2. Only call hooks from React functions (components or custom hooks)\r\n\r\n// ❌ Wrong: Conditional hook\r\nconst Component = ({ condition }: { condition: boolean }) => {\r\n  if (condition) {\r\n    const [state, setState] = useState(0); // Error!\r\n  }\r\n  return <div />;\r\n};\r\n\r\n// ✅ Correct: Always call hooks\r\nconst Component = ({ condition }: { condition: boolean }) => {\r\n  const [state, setState] = useState(0);\r\n\r\n  if (condition) {\r\n    // Use state here\r\n  }\r\n  return <div />;\r\n};\r\n\r\n// ❌ Wrong: Hook in loop\r\nconst Component = ({ items }: { items: Item[] }) => {\r\n  items.forEach((item) => {\r\n    const [state, setState] = useState(0); // Error!\r\n  });\r\n  return <div />;\r\n};\r\n\r\n// ✅ Correct: Extract to custom hook\r\nconst useItemState = (item: Item) => {\r\n  return useState(0);\r\n};\r\n\r\nconst Component = ({ items }: { items: Item[] }) => {\r\n  return (\r\n    <>\r\n      {items.map((item) => (\r\n        <ItemComponent key={item.id} item={item} />\r\n      ))}\r\n    </>\r\n  );\r\n};\r\n\r\n// ❌ Wrong: Hook in callback\r\nconst Component = () => {\r\n  const handleClick = () => {\r\n    const [state, setState] = useState(0); // Error!\r\n  };\r\n  return <button onClick={handleClick}>Click</button>;\r\n};\r\n\r\n// ✅ Correct: Call hook at top level\r\nconst Component = () => {\r\n  const [state, setState] = useState(0);\r\n\r\n  const handleClick = () => {\r\n    setState(state + 1);\r\n  };\r\n\r\n  return <button onClick={handleClick}>Click</button>;\r\n};\r\n\r\n// Best practices:\r\n// 1. Use ESLint plugin for hooks\r\n// 2. Extract complex logic to custom hooks\r\n// 3. Keep hooks focused and single-purpose\r\n// 4. Use dependency arrays correctly\r\n// 5. Clean up effects properly\r\n\r\n// Custom hook best practices\r\nconst useCounter = (initialValue = 0) => {\r\n  const [count, setCount] = useState(initialValue);\r\n\r\n  const increment = useCallback(() => {\r\n    setCount((prev) => prev + 1);\r\n  }, []);\r\n\r\n  const decrement = useCallback(() => {\r\n    setCount((prev) => prev - 1);\r\n  }, []);\r\n\r\n  const reset = useCallback(() => {\r\n    setCount(initialValue);\r\n  }, [initialValue]);\r\n\r\n  return { count, increment, decrement, reset };\r\n};\r\n```",
    "number": 17
  },
  {
    "id": "react-18",
    "topic": "react",
    "title": "Explain React Server Components (RSC)",
    "answer": "Server Components render on the server, reducing client bundle size and enabling direct database access.\r\n\r\n```typescript\r\n// Server Component (Next.js 13+ App Router)\r\n// app/users/page.tsx\r\nasync function UsersPage() {\r\n  // This runs on the server\r\n  const users = await fetch(\"https://api.example.com/users\").then((r) =>\r\n    r.json()\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <h1>Users</h1>\r\n      {users.map((user) => (\r\n        <UserCard key={user.id} user={user} />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Client Component (when interactivity needed)\r\n(\"use client\");\r\n\r\nimport { useState } from \"react\";\r\n\r\nconst InteractiveButton = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;\r\n};\r\n\r\n// Mixing Server and Client Components\r\n// Server Component\r\nasync function ProductPage({ id }: { id: string }) {\r\n  const product = await getProduct(id);\r\n\r\n  return (\r\n    <div>\r\n      <h1>{product.name}</h1>\r\n      <ProductDetails product={product} />\r\n      <AddToCartButton productId={id} /> {/* Client Component */}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Benefits:\r\n// - Smaller client bundle\r\n// - Direct database/API access\r\n// - Better security (secrets stay on server)\r\n// - Improved performance\r\n\r\n// Limitations:\r\n// - No useState, useEffect, event handlers\r\n// - No browser-only APIs\r\n// - Must use 'use client' for interactivity\r\n```",
    "number": 18
  },
  {
    "id": "react-19",
    "topic": "react",
    "title": "Explain React Suspense and Concurrent Features",
    "answer": "Suspense enables declarative loading states, and Concurrent React allows interruptible rendering.\r\n\r\n```typescript\r\nimport { Suspense, startTransition, useDeferredValue } from \"react\";\r\n\r\n// Basic Suspense\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <AsyncComponent />\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// Multiple Suspense boundaries\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<HeaderSkeleton />}>\r\n        <Header />\r\n      </Suspense>\r\n      <Suspense fallback={<ContentSkeleton />}>\r\n        <Content />\r\n      </Suspense>\r\n      <Suspense fallback={<SidebarSkeleton />}>\r\n        <Sidebar />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n};\r\n\r\n// useTransition for non-urgent updates\r\nconst SearchResults = ({ query }: { query: string }) => {\r\n  const [isPending, startTransition] = useTransition();\r\n  const [results, setResults] = useState<Result[]>([]);\r\n\r\n  useEffect(() => {\r\n    startTransition(() => {\r\n      // Non-urgent update\r\n      fetchResults(query).then(setResults);\r\n    });\r\n  }, [query]);\r\n\r\n  return (\r\n    <div>\r\n      {isPending && <div>Searching...</div>}\r\n      {results.map((result) => (\r\n        <ResultItem key={result.id} result={result} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// useDeferredValue for deferring values\r\nconst SearchInput = () => {\r\n  const [query, setQuery] = useState(\"\");\r\n  const deferredQuery = useDeferredValue(query);\r\n\r\n  return (\r\n    <div>\r\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <SearchResults query={deferredQuery} />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Concurrent rendering benefits:\r\n// - Interruptible rendering\r\n// - Automatic batching\r\n// - Prioritized updates\r\n// - Better user experience\r\n```",
    "number": 19
  },
  {
    "id": "react-20",
    "topic": "react",
    "title": "Explain React Testing Patterns",
    "answer": "Testing React components requires specific patterns and tools.\r\n\r\n```typescript\r\nimport { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\r\nimport { renderHook, act } from \"@testing-library/react-hooks\";\r\n\r\n// Component testing\r\nconst Button = ({ onClick, children }: ButtonProps) => {\r\n  return <button onClick={onClick}>{children}</button>;\r\n};\r\n\r\ntest(\"renders button and handles click\", () => {\r\n  const handleClick = jest.fn();\r\n  render(<Button onClick={handleClick}>Click me</Button>);\r\n\r\n  const button = screen.getByText(\"Click me\");\r\n  fireEvent.click(button);\r\n\r\n  expect(handleClick).toHaveBeenCalledTimes(1);\r\n});\r\n\r\n// Testing with hooks\r\nconst Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>{count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n};\r\n\r\ntest(\"increments count\", () => {\r\n  render(<Counter />);\r\n\r\n  const button = screen.getByText(\"Increment\");\r\n  const count = screen.getByText(\"0\");\r\n\r\n  fireEvent.click(button);\r\n\r\n  expect(screen.getByText(\"1\")).toBeInTheDocument();\r\n});\r\n\r\n// Testing async operations\r\nconst UserProfile = ({ userId }: { userId: number }) => {\r\n  const [user, setUser] = useState<User | null>(null);\r\n\r\n  useEffect(() => {\r\n    fetchUser(userId).then(setUser);\r\n  }, [userId]);\r\n\r\n  if (!user) return <div>Loading...</div>;\r\n\r\n  return <div>{user.name}</div>;\r\n};\r\n\r\ntest(\"loads and displays user\", async () => {\r\n  const mockUser = { id: 1, name: \"John\" };\r\n  jest.spyOn(global, \"fetch\").mockResolvedValue({\r\n    json: async () => mockUser,\r\n  } as Response);\r\n\r\n  render(<UserProfile userId={1} />);\r\n\r\n  expect(screen.getByText(\"Loading...\")).toBeInTheDocument();\r\n\r\n  await waitFor(() => {\r\n    expect(screen.getByText(\"John\")).toBeInTheDocument();\r\n  });\r\n});\r\n\r\n// Testing custom hooks\r\nconst useCounter = (initial = 0) => {\r\n  const [count, setCount] = useState(initial);\r\n\r\n  const increment = () => setCount(count + 1);\r\n  const decrement = () => setCount(count - 1);\r\n\r\n  return { count, increment, decrement };\r\n};\r\n\r\ntest(\"useCounter hook\", () => {\r\n  const { result } = renderHook(() => useCounter(0));\r\n\r\n  expect(result.current.count).toBe(0);\r\n\r\n  act(() => {\r\n    result.current.increment();\r\n  });\r\n\r\n  expect(result.current.count).toBe(1);\r\n\r\n  act(() => {\r\n    result.current.decrement();\r\n  });\r\n\r\n  expect(result.current.count).toBe(0);\r\n});\r\n\r\n// Testing with context\r\nconst ThemeContext = createContext<\"light\" | \"dark\">(\"light\");\r\n\r\nconst ThemedComponent = () => {\r\n  const theme = useContext(ThemeContext);\r\n  return <div data-theme={theme}>Content</div>;\r\n};\r\n\r\ntest(\"renders with theme context\", () => {\r\n  render(\r\n    <ThemeContext.Provider value=\"dark\">\r\n      <ThemedComponent />\r\n    </ThemeContext.Provider>\r\n  );\r\n\r\n  expect(screen.getByText(\"Content\")).toHaveAttribute(\"data-theme\", \"dark\");\r\n});\r\n```",
    "number": 20
  },
  {
    "id": "react-21",
    "topic": "react",
    "title": "Explain React Forms and Validation",
    "answer": "Forms in React can be handled with validation libraries or custom logic.\r\n\r\n```typescript\r\nimport { useState } from \"react\";\r\n\r\n// Basic form with validation\r\nconst LoginForm = () => {\r\n  const [formData, setFormData] = useState({\r\n    email: \"\",\r\n    password: \"\",\r\n  });\r\n  const [errors, setErrors] = useState<Record<string, string>>({});\r\n\r\n  const validate = () => {\r\n    const newErrors: Record<string, string> = {};\r\n\r\n    if (!formData.email) {\r\n      newErrors.email = \"Email is required\";\r\n    } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\r\n      newErrors.email = \"Email is invalid\";\r\n    }\r\n\r\n    if (!formData.password) {\r\n      newErrors.password = \"Password is required\";\r\n    } else if (formData.password.length < 8) {\r\n      newErrors.password = \"Password must be at least 8 characters\";\r\n    }\r\n\r\n    setErrors(newErrors);\r\n    return Object.keys(newErrors).length === 0;\r\n  };\r\n\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    if (validate()) {\r\n      // Submit form\r\n      console.log(\"Form submitted:\", formData);\r\n    }\r\n  };\r\n\r\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const { name, value } = e.target;\r\n    setFormData((prev) => ({ ...prev, [name]: value }));\r\n\r\n    // Clear error when user types\r\n    if (errors[name]) {\r\n      setErrors((prev) => ({ ...prev, [name]: \"\" }));\r\n    }\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <div>\r\n        <input\r\n          name=\"email\"\r\n          type=\"email\"\r\n          value={formData.email}\r\n          onChange={handleChange}\r\n        />\r\n        {errors.email && <span className=\"error\">{errors.email}</span>}\r\n      </div>\r\n\r\n      <div>\r\n        <input\r\n          name=\"password\"\r\n          type=\"password\"\r\n          value={formData.password}\r\n          onChange={handleChange}\r\n        />\r\n        {errors.password && <span className=\"error\">{errors.password}</span>}\r\n      </div>\r\n\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  );\r\n};\r\n\r\n// Using React Hook Form (popular library)\r\nimport { useForm } from \"react-hook-form\";\r\n\r\ninterface FormData {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nconst LoginFormRHF = () => {\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    formState: { errors },\r\n  } = useForm<FormData>();\r\n\r\n  const onSubmit = (data: FormData) => {\r\n    console.log(data);\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <input\r\n        {...register(\"email\", {\r\n          required: \"Email is required\",\r\n          pattern: {\r\n            value: /\\S+@\\S+\\.\\S+/,\r\n            message: \"Email is invalid\",\r\n          },\r\n        })}\r\n      />\r\n      {errors.email && <span>{errors.email.message}</span>}\r\n\r\n      <input\r\n        type=\"password\"\r\n        {...register(\"password\", {\r\n          required: \"Password is required\",\r\n          minLength: {\r\n            value: 8,\r\n            message: \"Password must be at least 8 characters\",\r\n          },\r\n        })}\r\n      />\r\n      {errors.password && <span>{errors.password.message}</span>}\r\n\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  );\r\n};\r\n```",
    "number": 21
  },
  {
    "id": "react-22",
    "topic": "react",
    "title": "Explain React Component Patterns",
    "answer": "Various patterns solve common React problems.\r\n\r\n```typescript\r\n// 1. Compound Components\r\nconst Tabs = ({ children }: { children: ReactNode }) => {\r\n  const [activeIndex, setActiveIndex] = useState(0);\r\n\r\n  return (\r\n    <TabsContext.Provider value={{ activeIndex, setActiveIndex }}>\r\n      {children}\r\n    </TabsContext.Provider>\r\n  );\r\n};\r\n\r\nconst TabsList = ({ children }: { children: ReactNode }) => {\r\n  return <div className=\"tabs-list\">{children}</div>;\r\n};\r\n\r\nconst TabsTrigger = ({ index, children }: TabsTriggerProps) => {\r\n  const { activeIndex, setActiveIndex } = useTabsContext();\r\n\r\n  return (\r\n    <button\r\n      className={activeIndex === index ? \"active\" : \"\"}\r\n      onClick={() => setActiveIndex(index)}\r\n    >\r\n      {children}\r\n    </button>\r\n  );\r\n};\r\n\r\nconst TabsContent = ({ index, children }: TabsContentProps) => {\r\n  const { activeIndex } = useTabsContext();\r\n\r\n  if (activeIndex !== index) return null;\r\n  return <div>{children}</div>;\r\n};\r\n\r\n// Usage\r\n<Tabs>\r\n  <TabsList>\r\n    <TabsTrigger index={0}>Tab 1</TabsTrigger>\r\n    <TabsTrigger index={1}>Tab 2</TabsTrigger>\r\n  </TabsList>\r\n  <TabsContent index={0}>Content 1</TabsContent>\r\n  <TabsContent index={1}>Content 2</TabsContent>\r\n</Tabs>;\r\n\r\n// 2. Render Props\r\ninterface DataFetcherProps<T> {\r\n  url: string;\r\n  children: (\r\n    data: T | null,\r\n    loading: boolean,\r\n    error: Error | null\r\n  ) => ReactNode;\r\n}\r\n\r\nconst DataFetcher = <T>({ url, children }: DataFetcherProps<T>) => {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  useEffect(() => {\r\n    fetch(url)\r\n      .then((r) => r.json())\r\n      .then(setData)\r\n      .catch(setError)\r\n      .finally(() => setLoading(false));\r\n  }, [url]);\r\n\r\n  return <>{children(data, loading, error)}</>;\r\n};\r\n\r\n// Usage\r\n<DataFetcher<User> url=\"/api/user\">\r\n  {(user, loading, error) => {\r\n    if (loading) return <div>Loading...</div>;\r\n    if (error) return <div>Error: {error.message}</div>;\r\n    return <div>{user?.name}</div>;\r\n  }}\r\n</DataFetcher>;\r\n\r\n// 3. Higher-Order Component (HOC)\r\nconst withAuth = <P extends object>(Component: React.ComponentType<P>) => {\r\n  return (props: P) => {\r\n    const { user } = useAuth();\r\n\r\n    if (!user) {\r\n      return <Navigate to=\"/login\" />;\r\n    }\r\n\r\n    return <Component {...props} />;\r\n  };\r\n};\r\n\r\nconst ProtectedComponent = withAuth(MyComponent);\r\n\r\n// 4. Children as Function\r\ninterface ToggleProps {\r\n  children: (isOpen: boolean, toggle: () => void) => ReactNode;\r\n}\r\n\r\nconst Toggle = ({ children }: ToggleProps) => {\r\n  const [isOpen, setIsOpen] = useState(false);\r\n\r\n  return <>{children(isOpen, () => setIsOpen(!isOpen))}</>;\r\n};\r\n\r\n// Usage\r\n<Toggle>\r\n  {(isOpen, toggle) => (\r\n    <div>\r\n      <button onClick={toggle}>Toggle</button>\r\n      {isOpen && <div>Content</div>}\r\n    </div>\r\n  )}\r\n</Toggle>;\r\n```",
    "number": 22
  },
  {
    "id": "react-23",
    "topic": "react",
    "title": "Explain React Virtual DOM and Reconciliation",
    "answer": "Virtual DOM is a JavaScript representation of the real DOM. Reconciliation is React's diffing algorithm.\r\n\r\n```typescript\r\n// Virtual DOM concept\r\n// React creates a virtual representation:\r\nconst virtualElement = {\r\n  type: 'div',\r\n  props: {\r\n    className: 'container',\r\n    children: [\r\n      {\r\n        type: 'h1',\r\n        props: { children: 'Hello' }\r\n      }\r\n    ]\r\n  }\r\n};\r\n\r\n// Reconciliation process:\r\n// 1. React creates new virtual DOM tree\r\n// 2. Compares with previous tree (diffing)\r\n// 3. Calculates minimal changes\r\n// 4. Updates only changed DOM nodes\r\n\r\n// Keys are crucial for reconciliation\r\nconst List = ({ items }: { items: Item[] }) => {\r\n  return (\r\n    <ul>\r\n      {items.map(item => (\r\n        <li key={item.id}>{item.name}</li>\r\n        // Key helps React identify which items changed\r\n      ))}\r\n    </ul>\r\n  );\r\n};\r\n\r\n// Without keys, React can't efficiently update\r\n// With keys, React can:\r\n// - Identify moved items\r\n// - Preserve component state\r\n// - Avoid unnecessary re-renders\r\n\r\n// Reconciliation rules:\r\n// 1. Elements of different types → Replace\r\n<div>\r\n  <Counter />\r\n</div>\r\n// Changes to:\r\n<span>\r\n  <Counter />\r\n</span>\r\n// Counter is unmounted and remounted\r\n\r\n// 2. Same element type → Update props\r\n<div className=\"before\" />\r\n// Changes to:\r\n<div className=\"after\" />\r\n// Only className is updated\r\n\r\n// 3. Component type changes → Unmount old, mount new\r\n<Button />\r\n// Changes to:\r\n<Input />\r\n// Button unmounts, Input mounts\r\n\r\n// 4. Keys help identify elements\r\n<ul>\r\n  <li key=\"1\">First</li>\r\n  <li key=\"2\">Second</li>\r\n</ul>\r\n// Changes to:\r\n<ul>\r\n  <li key=\"2\">Second</li>\r\n  <li key=\"1\">First</li>\r\n</ul>\r\n// React knows items moved, doesn't recreate them\r\n```",
    "number": 23
  },
  {
    "id": "react-24",
    "topic": "react",
    "title": "Explain React Fiber Architecture",
    "answer": "Fiber is React's reconciliation algorithm that enables incremental rendering and prioritization.\r\n\r\n```typescript\r\n// Fiber architecture benefits:\r\n// 1. Incremental rendering (can pause/resume work)\r\n// 2. Priority-based updates\r\n// 3. Better error boundaries\r\n// 4. Concurrent features\r\n\r\n// How it works:\r\n// - Each component has a Fiber node\r\n// - Fiber nodes form a tree\r\n// - Work can be split into units\r\n// - High-priority updates interrupt low-priority\r\n\r\n// Example: Priority-based updates\r\nconst App = () => {\r\n  const [urgent, setUrgent] = useState(\"\");\r\n  const [nonUrgent, setNonUrgent] = useState(\"\");\r\n\r\n  // Urgent update (user input)\r\n  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    setUrgent(e.target.value); // High priority\r\n  };\r\n\r\n  // Non-urgent update (search results)\r\n  const handleSearch = (query: string) => {\r\n    startTransition(() => {\r\n      setNonUrgent(query); // Low priority, can be interrupted\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input onChange={handleInput} />\r\n      <SearchResults query={nonUrgent} />\r\n    </div>\r\n  );\r\n};\r\n\r\n// Fiber enables:\r\n// - Time slicing (split work across frames)\r\n// - Suspense (pause rendering for async)\r\n// - Concurrent rendering\r\n// - Automatic batching\r\n```",
    "number": 24
  },
  {
    "id": "react-25",
    "topic": "react",
    "title": "Explain React Best Practices and Patterns",
    "answer": "Best practices improve code quality, performance, and maintainability.\r\n\r\n```typescript\r\n// 1. Component composition over inheritance\r\n// ❌ Bad: Inheritance\r\nclass Button extends BaseComponent {}\r\n\r\n// ✅ Good: Composition\r\nconst Button = ({ children, ...props }: ButtonProps) => {\r\n  return <BaseComponent {...props}>{children}</BaseComponent>;\r\n};\r\n\r\n// 2. Single Responsibility Principle\r\n// ❌ Bad: Component does too much\r\nconst UserDashboard = () => {\r\n  // User profile, settings, posts, comments all in one\r\n};\r\n\r\n// ✅ Good: Split into smaller components\r\nconst UserDashboard = () => {\r\n  return (\r\n    <div>\r\n      <UserProfile />\r\n      <UserSettings />\r\n      <UserPosts />\r\n    </div>\r\n  );\r\n};\r\n\r\n// 3. Extract custom hooks for reusable logic\r\n// ❌ Bad: Logic in component\r\nconst Component1 = () => {\r\n  const [data, setData] = useState(null);\r\n  useEffect(() => {\r\n    fetch(\"/api/data\")\r\n      .then((r) => r.json())\r\n      .then(setData);\r\n  }, []);\r\n};\r\n\r\nconst Component2 = () => {\r\n  // Duplicate logic\r\n};\r\n\r\n// ✅ Good: Custom hook\r\nconst useData = () => {\r\n  const [data, setData] = useState(null);\r\n  useEffect(() => {\r\n    fetch(\"/api/data\")\r\n      .then((r) => r.json())\r\n      .then(setData);\r\n  }, []);\r\n  return data;\r\n};\r\n\r\n// 4. Use TypeScript for type safety\r\ninterface UserProps {\r\n  name: string;\r\n  age: number;\r\n  email?: string;\r\n}\r\n\r\nconst User = ({ name, age, email }: UserProps) => {\r\n  // Type-safe props\r\n};\r\n\r\n// 5. Memoization when needed\r\nconst ExpensiveList = memo(({ items }: { items: Item[] }) => {\r\n  const sorted = useMemo(() => items.sort(), [items]);\r\n  return (\r\n    <div>\r\n      {sorted.map((item) => (\r\n        <Item key={item.id} {...item} />\r\n      ))}\r\n    </div>\r\n  );\r\n});\r\n\r\n// 6. Proper key usage\r\n// ✅ Good: Stable, unique keys\r\n{\r\n  users.map((user) => <UserCard key={user.id} user={user} />);\r\n}\r\n\r\n// ❌ Bad: Index as key (unless list is static)\r\n{\r\n  users.map((user, index) => <UserCard key={index} user={user} />);\r\n}\r\n\r\n// 7. Error boundaries for error handling\r\nclass ErrorBoundary extends React.Component<\r\n  { children: React.ReactNode; fallback?: React.ReactNode },\r\n  { hasError: boolean; error: Error | null }\r\n> {\r\n  constructor(props: any) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error) {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n    console.error(\"Error caught:\", error, errorInfo);\r\n    // Log to error reporting service\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return this.props.fallback || <div>Something went wrong</div>;\r\n    }\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\nconst App = () => {\r\n  return (\r\n    <ErrorBoundary fallback={<ErrorFallback />}>\r\n      <UserDashboard />\r\n    </ErrorBoundary>\r\n  );\r\n};\r\n\r\n// 8. Code splitting and lazy loading\r\nconst LazyComponent = React.lazy(() => import(\"./HeavyComponent\"));\r\n\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<Loading />}>\r\n      <LazyComponent />\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// 9. Proper prop destructuring\r\n// ❌ Bad: Accessing props directly\r\nconst User = (props: UserProps) => {\r\n  return <div>{props.name}</div>;\r\n};\r\n\r\n// ✅ Good: Destructure props\r\nconst User = ({ name, age, email }: UserProps) => {\r\n  return <div>{name}</div>;\r\n};\r\n\r\n// 10. Avoid inline object/function creation in render\r\n// ❌ Bad: Creates new object/function on every render\r\nconst Component = ({ items }: { items: Item[] }) => {\r\n  return <Child style={{ color: \"red\" }} onClick={() => {}} items={items} />;\r\n};\r\n\r\n// ✅ Good: Extract or memoize\r\nconst Component = ({ items }: { items: Item[] }) => {\r\n  const style = useMemo(() => ({ color: \"red\" }), []);\r\n  const handleClick = useCallback(() => {}, []);\r\n  return <Child style={style} onClick={handleClick} items={items} />;\r\n};\r\n\r\n// 11. Use proper event handlers\r\nconst Button = ({ onClick, children }: ButtonProps) => {\r\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\r\n    e.preventDefault();\r\n    onClick?.(e);\r\n  };\r\n  return <button onClick={handleClick}>{children}</button>;\r\n};\r\n\r\n// 12. Controlled vs Uncontrolled components\r\n// Controlled (recommended for forms)\r\nconst ControlledInput = () => {\r\n  const [value, setValue] = useState(\"\");\r\n  return <input value={value} onChange={(e) => setValue(e.target.value)} />;\r\n};\r\n\r\n// Uncontrolled (for simple cases)\r\nconst UncontrolledInput = () => {\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n  const handleSubmit = () => {\r\n    console.log(inputRef.current?.value);\r\n  };\r\n  return <input ref={inputRef} />;\r\n};\r\n\r\n// 13. Use React DevTools for debugging\r\n// - Component tree inspection\r\n// - Props and state inspection\r\n// - Performance profiling\r\n// - Hook inspection\r\n\r\n// 14. Follow naming conventions\r\n// Components: PascalCase (UserProfile)\r\n// Hooks: camelCase starting with 'use' (useUserData)\r\n// Props interfaces: ComponentNameProps (UserProfileProps)\r\n// Constants: UPPER_SNAKE_CASE (API_BASE_URL)\r\n\r\n// 15. Keep components small and focused\r\n// Each component should do one thing well\r\n// Extract complex logic into custom hooks\r\n// Use composition to build complex UIs\r\n```",
    "number": 25
  }
]