[
  {
    "id": "backend-1",
    "topic": "backend",
    "title": "Explain Node.js and Express.js Architecture and Middleware Pattern",
    "answer": "Node.js is a JavaScript runtime built on Chrome's V8 engine. Express.js is a minimalist web framework for Node.js.\r\n\r\n```javascript\r\n// Basic Express setup\r\nconst express = require('express');\r\nconst app = express();\r\n\r\n// Middleware (executed in order)\r\napp.use(express.json()); // Parse JSON bodies\r\napp.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies\r\napp.use(express.static('public')); // Serve static files\r\n\r\n// Custom middleware\r\napp.use((req, res, next) => {\r\n  console.log(`${req.method} ${req.path}`);\r\n  next(); // Pass control to next middleware\r\n});\r\n\r\n// Route handlers\r\napp.get('/api/users', (req, res) => {\r\n  res.json({ users: [] });\r\n});\r\n\r\napp.post('/api/users', (req, res) => {\r\n  const user = req.body;\r\n  res.status(201).json({ user });\r\n});\r\n\r\n// Error handling middleware (must be last)\r\napp.use((err, req, res, next) => {\r\n  console.error(err.stack);\r\n  res.status(500).json({ error: 'Something went wrong!' });\r\n});\r\n\r\n// Start server\r\nconst PORT = process.env.PORT || 3000;\r\napp.listen(PORT, () => {\r\n  console.log(`Server running on port ${PORT}`);\r\n});\r\n\r\n// Express Router (modular routes)\r\nconst router = express.Router();\r\n\r\nrouter.get('/', (req, res) => res.json({ message: 'Users API' }));\r\nrouter.get('/:id', (req, res) => {\r\n  const { id } = req.params;\r\n  res.json({ id });\r\n});\r\n\r\napp.use('/api/users', router);\r\n```",
    "number": 1
  },
  {
    "id": "backend-2",
    "topic": "backend",
    "title": "Explain JWT (JSON Web Token) Authentication: Generation, Verification, and Refresh Tokens",
    "answer": "JWT is a stateless authentication mechanism using signed tokens.\r\n\r\n```javascript\r\nconst jwt = require('jsonwebtoken');\r\nconst bcrypt = require('bcrypt');\r\n\r\n// JWT configuration\r\nconst JWT_SECRET = process.env.JWT_SECRET;\r\nconst JWT_EXPIRES_IN = '15m';\r\nconst REFRESH_TOKEN_EXPIRES_IN = '7d';\r\n\r\n// Generate access token\r\nfunction generateAccessToken(userId, email, role) {\r\n  return jwt.sign(\r\n    { userId, email, role }, // Payload\r\n    JWT_SECRET,\r\n    { expiresIn: JWT_EXPIRES_IN }\r\n  );\r\n}\r\n\r\n// Generate refresh token\r\nfunction generateRefreshToken(userId) {\r\n  return jwt.sign(\r\n    { userId, type: 'refresh' },\r\n    JWT_SECRET,\r\n    { expiresIn: REFRESH_TOKEN_EXPIRES_IN }\r\n  );\r\n}\r\n\r\n// Login endpoint\r\nasync function login(req, res) {\r\n  const { email, password } = req.body;\r\n  \r\n  // Find user and verify password\r\n  const user = await User.findOne({ email });\r\n  if (!user) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  const isValid = await bcrypt.compare(password, user.password);\r\n  if (!isValid) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  // Generate tokens\r\n  const accessToken = generateAccessToken(user.id, user.email, user.role);\r\n  const refreshToken = generateRefreshToken(user.id);\r\n  \r\n  // Store refresh token in database (optional)\r\n  await User.updateOne(\r\n    { _id: user.id },\r\n    { refreshToken: await bcrypt.hash(refreshToken, 10) }\r\n  );\r\n  \r\n  res.json({\r\n    accessToken,\r\n    refreshToken,\r\n    user: { id: user.id, email: user.email, role: user.role }\r\n  });\r\n}\r\n\r\n// Refresh token endpoint\r\nasync function refreshToken(req, res) {\r\n  const { refreshToken } = req.body;\r\n  \r\n  try {\r\n    const decoded = jwt.verify(refreshToken, JWT_SECRET);\r\n    \r\n    if (decoded.type !== 'refresh') {\r\n      return res.status(401).json({ error: 'Invalid token type' });\r\n    }\r\n    \r\n    const user = await User.findById(decoded.userId);\r\n    if (!user) {\r\n      return res.status(401).json({ error: 'User not found' });\r\n    }\r\n    \r\n    // Generate new access token\r\n    const newAccessToken = generateAccessToken(user.id, user.email, user.role);\r\n    \r\n    res.json({ accessToken: newAccessToken });\r\n  } catch (error) {\r\n    res.status(401).json({ error: 'Invalid refresh token' });\r\n  }\r\n}\r\n\r\n// JWT verification middleware\r\nfunction authenticateToken(req, res, next) {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\r\n  \r\n  if (!token) {\r\n    return res.status(401).json({ error: 'Access token required' });\r\n  }\r\n  \r\n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\r\n    if (err) {\r\n      return res.status(403).json({ error: 'Invalid or expired token' });\r\n    }\r\n    \r\n    req.user = decoded; // Attach user info to request\r\n    next();\r\n  });\r\n}\r\n\r\n// Protected route\r\napp.get('/api/profile', authenticateToken, (req, res) => {\r\n  res.json({ user: req.user });\r\n});\r\n```",
    "number": 2
  },
  {
    "id": "backend-3",
    "topic": "backend",
    "title": "Explain Session-Based Authentication: Express-Session, Redis Store, and Cookie Configuration",
    "answer": "Session-based authentication stores user state on the server using cookies.\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst session = require('express-session');\r\nconst RedisStore = require('connect-redis').default;\r\nconst redis = require('redis');\r\n\r\nconst app = express();\r\n\r\n// Redis client\r\nconst redisClient = redis.createClient({\r\n  host: process.env.REDIS_HOST,\r\n  port: process.env.REDIS_PORT,\r\n  password: process.env.REDIS_PASSWORD\r\n});\r\n\r\nredisClient.connect().catch(console.error);\r\n\r\n// Session configuration\r\napp.use(session({\r\n  store: new RedisStore({ client: redisClient }),\r\n  secret: process.env.SESSION_SECRET,\r\n  resave: false, // Don't save session if unmodified\r\n  saveUninitialized: false, // Don't create session until something stored\r\n  name: 'sessionId', // Custom session name\r\n  cookie: {\r\n    secure: process.env.NODE_ENV === 'production', // HTTPS only in production\r\n    httpOnly: true, // Prevent XSS attacks\r\n    maxAge: 1000 * 60 * 60 * 24, // 24 hours\r\n    sameSite: 'strict' // CSRF protection\r\n  }\r\n}));\r\n\r\n// Login endpoint\r\napp.post('/api/login', async (req, res) => {\r\n  const { email, password } = req.body;\r\n  \r\n  const user = await User.findOne({ email });\r\n  if (!user) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  const isValid = await bcrypt.compare(password, user.password);\r\n  if (!isValid) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  // Store user info in session\r\n  req.session.userId = user.id;\r\n  req.session.email = user.email;\r\n  req.session.role = user.role;\r\n  \r\n  res.json({ message: 'Login successful', user: { id: user.id, email: user.email } });\r\n});\r\n\r\n// Session authentication middleware\r\nfunction requireAuth(req, res, next) {\r\n  if (req.session && req.session.userId) {\r\n    return next();\r\n  }\r\n  res.status(401).json({ error: 'Authentication required' });\r\n}\r\n\r\n// Protected route\r\napp.get('/api/profile', requireAuth, async (req, res) => {\r\n  const user = await User.findById(req.session.userId);\r\n  res.json({ user });\r\n});\r\n\r\n// Logout endpoint\r\napp.post('/api/logout', (req, res) => {\r\n  req.session.destroy((err) => {\r\n    if (err) {\r\n      return res.status(500).json({ error: 'Logout failed' });\r\n    }\r\n    res.clearCookie('sessionId');\r\n    res.json({ message: 'Logout successful' });\r\n  });\r\n});\r\n\r\n// Session store in memory (development only)\r\napp.use(session({\r\n  secret: 'your-secret-key',\r\n  resave: false,\r\n  saveUninitialized: false\r\n}));\r\n```",
    "number": 3
  },
  {
    "id": "backend-4",
    "topic": "backend",
    "title": "Explain Global Error Handling: Centralized Error Handler, Custom Error Classes, and Async Error Wrapper",
    "answer": "Global error handling provides consistent error responses across the application.\r\n\r\n```javascript\r\n// Custom Error Classes\r\nclass AppError extends Error {\r\n  constructor(message, statusCode) {\r\n    super(message);\r\n    this.statusCode = statusCode;\r\n    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\r\n    this.isOperational = true;\r\n    \r\n    Error.captureStackTrace(this, this.constructor);\r\n  }\r\n}\r\n\r\nclass NotFoundError extends AppError {\r\n  constructor(message = 'Resource not found') {\r\n    super(message, 404);\r\n  }\r\n}\r\n\r\nclass ValidationError extends AppError {\r\n  constructor(message = 'Validation failed', errors = []) {\r\n    super(message, 400);\r\n    this.errors = errors;\r\n  }\r\n}\r\n\r\nclass UnauthorizedError extends AppError {\r\n  constructor(message = 'Unauthorized') {\r\n    super(message, 401);\r\n  }\r\n}\r\n\r\n// Async error wrapper (catch async errors)\r\nconst catchAsync = (fn) => {\r\n  return (req, res, next) => {\r\n    Promise.resolve(fn(req, res, next)).catch(next);\r\n  };\r\n};\r\n\r\n// Usage with async handler\r\napp.get('/api/users/:id', catchAsync(async (req, res, next) => {\r\n  const user = await User.findById(req.params.id);\r\n  \r\n  if (!user) {\r\n    throw new NotFoundError('User not found');\r\n  }\r\n  \r\n  res.json({ user });\r\n}));\r\n\r\n// Global error handling middleware (must be last)\r\nfunction errorHandler(err, req, res, next) {\r\n  let error = { ...err };\r\n  error.message = err.message;\r\n  \r\n  // Log error\r\n  console.error('Error:', err);\r\n  \r\n  // Mongoose bad ObjectId\r\n  if (err.name === 'CastError') {\r\n    const message = 'Resource not found';\r\n    error = new NotFoundError(message);\r\n  }\r\n  \r\n  // Mongoose duplicate key\r\n  if (err.code === 11000) {\r\n    const message = 'Duplicate field value entered';\r\n    error = new ValidationError(message);\r\n  }\r\n  \r\n  // Mongoose validation error\r\n  if (err.name === 'ValidationError') {\r\n    const errors = Object.values(err.errors).map(e => e.message);\r\n    const message = 'Validation failed';\r\n    error = new ValidationError(message, errors);\r\n  }\r\n  \r\n  // JWT errors\r\n  if (err.name === 'JsonWebTokenError') {\r\n    error = new UnauthorizedError('Invalid token');\r\n  }\r\n  \r\n  if (err.name === 'TokenExpiredError') {\r\n    error = new UnauthorizedError('Token expired');\r\n  }\r\n  \r\n  // Default error\r\n  const statusCode = error.statusCode || 500;\r\n  const status = error.status || 'error';\r\n  \r\n  res.status(statusCode).json({\r\n    status,\r\n    message: error.message || 'Internal server error',\r\n    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),\r\n    ...(error.errors && { errors: error.errors })\r\n  });\r\n}\r\n\r\n// Not found handler\r\napp.use((req, res, next) => {\r\n  next(new NotFoundError(`Route ${req.originalUrl} not found`));\r\n});\r\n\r\n// Apply error handler\r\napp.use(errorHandler);\r\n```",
    "number": 4
  },
  {
    "id": "backend-5",
    "topic": "backend",
    "title": "Explain API Versioning: URL Versioning, Header Versioning, and Version Strategy",
    "answer": "API versioning allows backward compatibility while introducing breaking changes.\r\n\r\n```javascript\r\n// URL-based versioning (most common)\r\n// /api/v1/users\r\n// /api/v2/users\r\n\r\n// Version 1 routes\r\nconst v1Router = express.Router();\r\nv1Router.get('/users', (req, res) => {\r\n  res.json({ version: 'v1', users: [] });\r\n});\r\n\r\n// Version 2 routes\r\nconst v2Router = express.Router();\r\nv2Router.get('/users', (req, res) => {\r\n  res.json({ version: 'v2', users: [], metadata: {} });\r\n});\r\n\r\napp.use('/api/v1', v1Router);\r\napp.use('/api/v2', v2Router);\r\n\r\n// Header-based versioning\r\n// Accept: application/vnd.api+json;version=2\r\nfunction versionMiddleware(req, res, next) {\r\n  const acceptHeader = req.headers.accept || '';\r\n  const versionMatch = acceptHeader.match(/version=(\\d+)/);\r\n  req.apiVersion = versionMatch ? versionMatch[1] : '1';\r\n  next();\r\n}\r\n\r\napp.use('/api', versionMiddleware);\r\n\r\napp.get('/api/users', (req, res) => {\r\n  if (req.apiVersion === '2') {\r\n    return res.json({ version: 'v2', users: [] });\r\n  }\r\n  res.json({ version: 'v1', users: [] });\r\n});\r\n\r\n// Versioned route handler factory\r\nfunction createVersionedRouter() {\r\n  const router = express.Router({ mergeParams: true });\r\n  \r\n  router.get('/users', async (req, res) => {\r\n    const version = req.params.version || 'v1';\r\n    \r\n    if (version === 'v2') {\r\n      return res.json({ version: 'v2', users: [], pagination: {} });\r\n    }\r\n    \r\n    res.json({ version: 'v1', users: [] });\r\n  });\r\n  \r\n  return router;\r\n}\r\n\r\n// Apply versioned routes\r\napp.use('/api/:version', createVersionedRouter());\r\n\r\n// Version middleware to validate version\r\nfunction validateVersion(req, res, next) {\r\n  const supportedVersions = ['v1', 'v2', 'v3'];\r\n  const version = req.params.version || req.apiVersion;\r\n  \r\n  if (version && !supportedVersions.includes(version)) {\r\n    return res.status(400).json({\r\n      error: 'Unsupported API version',\r\n      supportedVersions\r\n    });\r\n  }\r\n  \r\n  next();\r\n}\r\n\r\napp.use('/api/:version', validateVersion);\r\n\r\n// Default version redirect\r\napp.use('/api/users', (req, res, next) => {\r\n  res.redirect(301, '/api/v1/users');\r\n});\r\n```",
    "number": 5
  },
  {
    "id": "backend-6",
    "topic": "backend",
    "title": "Explain Stripe Payment Integration: Payment Intents, Webhooks, and Subscription Management",
    "answer": "Stripe provides secure payment processing with PCI compliance handled by Stripe.\r\n\r\n```javascript\r\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\r\nconst express = require('express');\r\n\r\n// Create payment intent\r\napp.post('/api/payments/create-intent', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { amount, currency = 'usd', metadata = {} } = req.body;\r\n    \r\n    const paymentIntent = await stripe.paymentIntents.create({\r\n      amount: amount * 100, // Convert to cents\r\n      currency,\r\n      metadata: {\r\n        userId: req.user.userId,\r\n        ...metadata\r\n      },\r\n      automatic_payment_methods: {\r\n        enabled: true\r\n      }\r\n    });\r\n    \r\n    res.json({\r\n      clientSecret: paymentIntent.client_secret\r\n    });\r\n  } catch (error) {\r\n    res.status(400).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Confirm payment\r\napp.post('/api/payments/confirm', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { paymentIntentId } = req.body;\r\n    \r\n    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);\r\n    \r\n    if (paymentIntent.status === 'succeeded') {\r\n      // Update order status in database\r\n      await Order.updateOne(\r\n        { paymentIntentId },\r\n        { status: 'paid', paidAt: new Date() }\r\n      );\r\n      \r\n      res.json({ success: true, paymentIntent });\r\n    } else {\r\n      res.status(400).json({ error: 'Payment not completed' });\r\n    }\r\n  } catch (error) {\r\n    res.status(400).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Stripe webhook handler\r\napp.post('/api/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\r\n  const sig = req.headers['stripe-signature'];\r\n  \r\n  let event;\r\n  \r\n  try {\r\n    event = stripe.webhooks.constructEvent(\r\n      req.body,\r\n      sig,\r\n      process.env.STRIPE_WEBHOOK_SECRET\r\n    );\r\n  } catch (err) {\r\n    return res.status(400).send(`Webhook Error: ${err.message}`);\r\n  }\r\n  \r\n  // Handle the event\r\n  switch (event.type) {\r\n    case 'payment_intent.succeeded':\r\n      const paymentIntent = event.data.object;\r\n      await handlePaymentSuccess(paymentIntent);\r\n      break;\r\n    \r\n    case 'payment_intent.payment_failed':\r\n      const failedPayment = event.data.object;\r\n      await handlePaymentFailure(failedPayment);\r\n      break;\r\n    \r\n    case 'customer.subscription.created':\r\n    case 'customer.subscription.updated':\r\n      const subscription = event.data.object;\r\n      await handleSubscriptionUpdate(subscription);\r\n      break;\r\n    \r\n    case 'customer.subscription.deleted':\r\n      const deletedSubscription = event.data.object;\r\n      await handleSubscriptionCancellation(deletedSubscription);\r\n      break;\r\n    \r\n    default:\r\n      console.log(`Unhandled event type ${event.type}`);\r\n  }\r\n  \r\n  res.json({ received: true });\r\n});\r\n\r\n// Subscription management\r\napp.post('/api/subscriptions/create', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { priceId, paymentMethodId } = req.body;\r\n    \r\n    // Create or retrieve customer\r\n    let customer = await Customer.findOne({ userId: req.user.userId });\r\n    let stripeCustomerId;\r\n    \r\n    if (customer && customer.stripeCustomerId) {\r\n      stripeCustomerId = customer.stripeCustomerId;\r\n    } else {\r\n      const stripeCustomer = await stripe.customers.create({\r\n        email: req.user.email,\r\n        metadata: { userId: req.user.userId }\r\n      });\r\n      stripeCustomerId = stripeCustomer.id;\r\n      \r\n      if (customer) {\r\n        customer.stripeCustomerId = stripeCustomerId;\r\n        await customer.save();\r\n      } else {\r\n        await Customer.create({\r\n          userId: req.user.userId,\r\n          stripeCustomerId\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Attach payment method\r\n    await stripe.paymentMethods.attach(paymentMethodId, {\r\n      customer: stripeCustomerId\r\n    });\r\n    \r\n    // Set as default payment method\r\n    await stripe.customers.update(stripeCustomerId, {\r\n      invoice_settings: {\r\n        default_payment_method: paymentMethodId\r\n      }\r\n    });\r\n    \r\n    // Create subscription\r\n    const subscription = await stripe.subscriptions.create({\r\n      customer: stripeCustomerId,\r\n      items: [{ price: priceId }],\r\n      expand: ['latest_invoice.payment_intent']\r\n    });\r\n    \r\n    res.json({ subscription });\r\n  } catch (error) {\r\n    res.status(400).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Cancel subscription\r\napp.post('/api/subscriptions/:id/cancel', authenticateToken, async (req, res) => {\r\n  try {\r\n    const subscription = await stripe.subscriptions.update(req.params.id, {\r\n      cancel_at_period_end: true\r\n    });\r\n    \r\n    res.json({ subscription });\r\n  } catch (error) {\r\n    res.status(400).json({ error: error.message });\r\n  }\r\n});\r\n```",
    "number": 6
  },
  {
    "id": "backend-7",
    "topic": "backend",
    "title": "Explain Layered Architecture: Routes, Controllers, Services, Repositories, and Models",
    "answer": "Layered architecture separates concerns for maintainability and testability.\r\n\r\n```javascript\r\n// Model Layer (Database schema)\r\n// models/User.js\r\nconst mongoose = require('mongoose');\r\n\r\nconst userSchema = new mongoose.Schema({\r\n  email: { type: String, required: true, unique: true },\r\n  password: { type: String, required: true },\r\n  role: { type: String, enum: ['user', 'admin'], default: 'user' }\r\n}, { timestamps: true });\r\n\r\nmodule.exports = mongoose.model('User', userSchema);\r\n\r\n// Repository Layer (Data access)\r\n// repositories/userRepository.js\r\nconst User = require('../models/User');\r\n\r\nclass UserRepository {\r\n  async findById(id) {\r\n    return await User.findById(id);\r\n  }\r\n  \r\n  async findByEmail(email) {\r\n    return await User.findOne({ email });\r\n  }\r\n  \r\n  async create(userData) {\r\n    return await User.create(userData);\r\n  }\r\n  \r\n  async update(id, updateData) {\r\n    return await User.findByIdAndUpdate(id, updateData, { new: true });\r\n  }\r\n  \r\n  async delete(id) {\r\n    return await User.findByIdAndDelete(id);\r\n  }\r\n  \r\n  async findAll(filters = {}, options = {}) {\r\n    const { page = 1, limit = 10 } = options;\r\n    const skip = (page - 1) * limit;\r\n    \r\n    return await User.find(filters)\r\n      .skip(skip)\r\n      .limit(limit);\r\n  }\r\n}\r\n\r\nmodule.exports = new UserRepository();\r\n\r\n// Service Layer (Business logic)\r\n// services/userService.js\r\nconst userRepository = require('../repositories/userRepository');\r\nconst bcrypt = require('bcrypt');\r\nconst { AppError } = require('../utils/errors');\r\n\r\nclass UserService {\r\n  async getUserById(id) {\r\n    const user = await userRepository.findById(id);\r\n    if (!user) {\r\n      throw new AppError('User not found', 404);\r\n    }\r\n    return user;\r\n  }\r\n  \r\n  async createUser(userData) {\r\n    const existingUser = await userRepository.findByEmail(userData.email);\r\n    if (existingUser) {\r\n      throw new AppError('Email already exists', 400);\r\n    }\r\n    \r\n    const hashedPassword = await bcrypt.hash(userData.password, 10);\r\n    \r\n    return await userRepository.create({\r\n      ...userData,\r\n      password: hashedPassword\r\n    });\r\n  }\r\n  \r\n  async updateUser(id, updateData) {\r\n    if (updateData.password) {\r\n      updateData.password = await bcrypt.hash(updateData.password, 10);\r\n    }\r\n    \r\n    return await userRepository.update(id, updateData);\r\n  }\r\n  \r\n  async deleteUser(id) {\r\n    return await userRepository.delete(id);\r\n  }\r\n  \r\n  async getUsers(filters, options) {\r\n    return await userRepository.findAll(filters, options);\r\n  }\r\n}\r\n\r\nmodule.exports = new UserService();\r\n\r\n// Controller Layer (Request/Response handling)\r\n// controllers/userController.js\r\nconst userService = require('../services/userService');\r\nconst catchAsync = require('../utils/catchAsync');\r\n\r\nclass UserController {\r\n  getUsers = catchAsync(async (req, res) => {\r\n    const { page, limit, ...filters } = req.query;\r\n    const users = await userService.getUsers(filters, { page, limit });\r\n    res.json({ users });\r\n  });\r\n  \r\n  getUserById = catchAsync(async (req, res) => {\r\n    const user = await userService.getUserById(req.params.id);\r\n    res.json({ user });\r\n  });\r\n  \r\n  createUser = catchAsync(async (req, res) => {\r\n    const user = await userService.createUser(req.body);\r\n    res.status(201).json({ user });\r\n  });\r\n  \r\n  updateUser = catchAsync(async (req, res) => {\r\n    const user = await userService.updateUser(req.params.id, req.body);\r\n    res.json({ user });\r\n  });\r\n  \r\n  deleteUser = catchAsync(async (req, res) => {\r\n    await userService.deleteUser(req.params.id);\r\n    res.status(204).send();\r\n  });\r\n}\r\n\r\nmodule.exports = new UserController();\r\n\r\n// Route Layer (API endpoints)\r\n// routes/userRoutes.js\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst userController = require('../controllers/userController');\r\nconst { authenticateToken } = require('../middleware/auth');\r\nconst { validateUser } = require('../middleware/validation');\r\n\r\nrouter.get('/', authenticateToken, userController.getUsers);\r\nrouter.get('/:id', authenticateToken, userController.getUserById);\r\nrouter.post('/', validateUser, userController.createUser);\r\nrouter.put('/:id', authenticateToken, validateUser, userController.updateUser);\r\nrouter.delete('/:id', authenticateToken, userController.deleteUser);\r\n\r\nmodule.exports = router;\r\n\r\n// app.js\r\nconst userRoutes = require('./routes/userRoutes');\r\napp.use('/api/v1/users', userRoutes);\r\n```",
    "number": 7
  },
  {
    "id": "backend-8",
    "topic": "backend",
    "title": "Explain Authentication Middleware: JWT Verification, Role-Based Access, and Request Context",
    "answer": "Authentication middleware validates tokens and attaches user context to requests.\r\n\r\n```javascript\r\nconst jwt = require('jsonwebtoken');\r\nconst { AppError, UnauthorizedError } = require('../utils/errors');\r\n\r\n// Basic authentication middleware\r\nfunction authenticateToken(req, res, next) {\r\n  try {\r\n    const authHeader = req.headers.authorization;\r\n    \r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n      throw new UnauthorizedError('Access token required');\r\n    }\r\n    \r\n    const token = authHeader.split(' ')[1];\r\n    \r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n    \r\n    // Attach user info to request\r\n    req.user = {\r\n      userId: decoded.userId,\r\n      email: decoded.email,\r\n      role: decoded.role\r\n    };\r\n    \r\n    next();\r\n  } catch (error) {\r\n    if (error.name === 'JsonWebTokenError') {\r\n      return next(new UnauthorizedError('Invalid token'));\r\n    }\r\n    if (error.name === 'TokenExpiredError') {\r\n      return next(new UnauthorizedError('Token expired'));\r\n    }\r\n    next(error);\r\n  }\r\n}\r\n\r\n// Optional authentication (doesn't fail if no token)\r\nfunction optionalAuth(req, res, next) {\r\n  try {\r\n    const authHeader = req.headers.authorization;\r\n    \r\n    if (authHeader && authHeader.startsWith('Bearer ')) {\r\n      const token = authHeader.split(' ')[1];\r\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n      req.user = decoded;\r\n    }\r\n    \r\n    next();\r\n  } catch (error) {\r\n    // Ignore errors, continue without auth\r\n    next();\r\n  }\r\n}\r\n\r\n// Role-based authorization middleware\r\nfunction authorize(...roles) {\r\n  return (req, res, next) => {\r\n    if (!req.user) {\r\n      return next(new UnauthorizedError('Authentication required'));\r\n    }\r\n    \r\n    if (!roles.includes(req.user.role)) {\r\n      return next(new AppError('Forbidden: Insufficient permissions', 403));\r\n    }\r\n    \r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.get('/api/admin/users', authenticateToken, authorize('admin'), getUsers);\r\napp.get('/api/users', authenticateToken, getUsers); // Any authenticated user\r\n\r\n// Permission-based middleware\r\nfunction requirePermission(permission) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return next(new UnauthorizedError('Authentication required'));\r\n    }\r\n    \r\n    const user = await User.findById(req.user.userId).populate('role');\r\n    \r\n    if (!user.role.permissions.includes(permission)) {\r\n      return next(new AppError('Forbidden: Permission denied', 403));\r\n    }\r\n    \r\n    next();\r\n  };\r\n}\r\n\r\n// Resource ownership middleware\r\nfunction requireOwnership(modelName) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return next(new UnauthorizedError('Authentication required'));\r\n    }\r\n    \r\n    const Model = require(`../models/${modelName}`);\r\n    const resource = await Model.findById(req.params.id);\r\n    \r\n    if (!resource) {\r\n      return next(new AppError('Resource not found', 404));\r\n    }\r\n    \r\n    // Check if user owns resource or is admin\r\n    if (resource.userId.toString() !== req.user.userId && req.user.role !== 'admin') {\r\n      return next(new AppError('Forbidden: Not authorized to access this resource', 403));\r\n    }\r\n    \r\n    req.resource = resource;\r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.put('/api/posts/:id', authenticateToken, requireOwnership('Post'), updatePost);\r\n\r\n// Rate limiting middleware (example)\r\nconst rateLimit = require('express-rate-limit');\r\n\r\nconst authLimiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 5, // 5 requests per window\r\n  message: 'Too many login attempts, please try again later'\r\n});\r\n\r\napp.post('/api/login', authLimiter, login);\r\n```",
    "number": 8
  },
  {
    "id": "backend-9",
    "topic": "backend",
    "title": "Explain Schema Validation Middleware: Joi, Zod, and Express Validator",
    "answer": "Schema validation ensures request data meets required formats and constraints.\r\n\r\n```javascript\r\n// Using Joi\r\nconst Joi = require('joi');\r\n\r\n// Validation schemas\r\nconst userSchema = Joi.object({\r\n  email: Joi.string().email().required(),\r\n  password: Joi.string().min(8).required(),\r\n  role: Joi.string().valid('user', 'admin').default('user')\r\n});\r\n\r\nconst updateUserSchema = Joi.object({\r\n  email: Joi.string().email().optional(),\r\n  password: Joi.string().min(8).optional(),\r\n  role: Joi.string().valid('user', 'admin').optional()\r\n}).min(1);\r\n\r\n// Validation middleware factory\r\nfunction validate(schema) {\r\n  return (req, res, next) => {\r\n    const { error, value } = schema.validate(req.body, {\r\n      abortEarly: false,\r\n      stripUnknown: true\r\n    });\r\n    \r\n    if (error) {\r\n      const errors = error.details.map(detail => ({\r\n        field: detail.path.join('.'),\r\n        message: detail.message\r\n      }));\r\n      \r\n      return res.status(400).json({\r\n        error: 'Validation failed',\r\n        errors\r\n      });\r\n    }\r\n    \r\n    req.validated = value;\r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.post('/api/users', validate(userSchema), createUser);\r\napp.put('/api/users/:id', validate(updateUserSchema), updateUser);\r\n\r\n// Using Express Validator\r\nconst { body, param, query, validationResult } = require('express-validator');\r\n\r\nconst validateUser = [\r\n  body('email').isEmail().withMessage('Invalid email format'),\r\n  body('password')\r\n    .isLength({ min: 8 })\r\n    .withMessage('Password must be at least 8 characters')\r\n    .matches(/[A-Z]/)\r\n    .withMessage('Password must contain at least one uppercase letter'),\r\n  body('role').optional().isIn(['user', 'admin']).withMessage('Invalid role'),\r\n  (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({\r\n        error: 'Validation failed',\r\n        errors: errors.array()\r\n      });\r\n    }\r\n    next();\r\n  }\r\n];\r\n\r\nconst validateId = [\r\n  param('id').isMongoId().withMessage('Invalid ID format'),\r\n  (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    next();\r\n  }\r\n];\r\n\r\n// Usage\r\napp.post('/api/users', validateUser, createUser);\r\napp.get('/api/users/:id', validateId, getUserById);\r\n\r\n// Using Zod (TypeScript-friendly)\r\nconst { z } = require('zod');\r\n\r\nconst userSchema = z.object({\r\n  email: z.string().email('Invalid email format'),\r\n  password: z.string().min(8, 'Password must be at least 8 characters'),\r\n  role: z.enum(['user', 'admin']).default('user')\r\n});\r\n\r\nfunction validateZod(schema) {\r\n  return (req, res, next) => {\r\n    try {\r\n      req.validated = schema.parse(req.body);\r\n      next();\r\n    } catch (error) {\r\n      if (error instanceof z.ZodError) {\r\n        return res.status(400).json({\r\n          error: 'Validation failed',\r\n          errors: error.errors.map(err => ({\r\n            field: err.path.join('.'),\r\n            message: err.message\r\n          }))\r\n        });\r\n      }\r\n      next(error);\r\n    }\r\n  };\r\n}\r\n\r\n// Usage\r\napp.post('/api/users', validateZod(userSchema), createUser);\r\n\r\n// Query parameter validation\r\nconst paginationSchema = Joi.object({\r\n  page: Joi.number().integer().min(1).default(1),\r\n  limit: Joi.number().integer().min(1).max(100).default(10),\r\n  sort: Joi.string().valid('asc', 'desc').default('desc')\r\n});\r\n\r\nfunction validateQuery(schema) {\r\n  return (req, res, next) => {\r\n    const { error, value } = schema.validate(req.query);\r\n    if (error) {\r\n      return res.status(400).json({ error: error.details[0].message });\r\n    }\r\n    req.query = value;\r\n    next();\r\n  };\r\n}\r\n\r\napp.get('/api/users', validateQuery(paginationSchema), getUsers);\r\n```",
    "number": 9
  },
  {
    "id": "backend-10",
    "topic": "backend",
    "title": "Explain Microservices Architecture: Service Communication, API Gateway, and Service Discovery",
    "answer": "Microservices architecture splits applications into independent, loosely coupled services.\r\n\r\n```javascript\r\n// Service A: User Service\r\n// services/user-service/server.js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\napp.get('/api/users/:id', async (req, res) => {\r\n  const user = await User.findById(req.params.id);\r\n  res.json({ user });\r\n});\r\n\r\napp.listen(3001, () => {\r\n  console.log('User Service running on port 3001');\r\n});\r\n\r\n// Service B: Order Service\r\n// services/order-service/server.js\r\nconst express = require('express');\r\nconst axios = require('axios');\r\nconst app = express();\r\n\r\napp.get('/api/orders/:id', async (req, res) => {\r\n  const order = await Order.findById(req.params.id);\r\n  \r\n  // Inter-service communication\r\n  const userResponse = await axios.get(`http://user-service:3001/api/users/${order.userId}`);\r\n  order.user = userResponse.data.user;\r\n  \r\n  res.json({ order });\r\n});\r\n\r\napp.listen(3002, () => {\r\n  console.log('Order Service running on port 3002');\r\n});\r\n\r\n// API Gateway\r\n// gateway/server.js\r\nconst express = require('express');\r\nconst { createProxyMiddleware } = require('http-proxy-middleware');\r\nconst app = express();\r\n\r\n// Route to user service\r\napp.use('/api/users', createProxyMiddleware({\r\n  target: 'http://user-service:3001',\r\n  changeOrigin: true,\r\n  pathRewrite: { '^/api': '' }\r\n}));\r\n\r\n// Route to order service\r\napp.use('/api/orders', createProxyMiddleware({\r\n  target: 'http://order-service:3002',\r\n  changeOrigin: true,\r\n  pathRewrite: { '^/api': '' }\r\n}));\r\n\r\n// Authentication middleware for gateway\r\napp.use('/api', authenticateToken);\r\n\r\napp.listen(3000, () => {\r\n  console.log('API Gateway running on port 3000');\r\n});\r\n\r\n// Service discovery (using Consul)\r\nconst consul = require('consul')();\r\n\r\n// Register service\r\nconsul.agent.service.register({\r\n  name: 'user-service',\r\n  address: 'localhost',\r\n  port: 3001,\r\n  check: {\r\n    http: 'http://localhost:3001/health',\r\n    interval: '10s'\r\n  }\r\n}, (err) => {\r\n  if (err) throw err;\r\n  console.log('User service registered');\r\n});\r\n\r\n// Discover service\r\nasync function discoverService(serviceName) {\r\n  const services = await consul.health.service({\r\n    service: serviceName,\r\n    passing: true\r\n  });\r\n  \r\n  if (services.length === 0) {\r\n    throw new Error(`Service ${serviceName} not found`);\r\n  }\r\n  \r\n  const service = services[0].Service;\r\n  return `http://${service.Address}:${service.Port}`;\r\n}\r\n\r\n// Inter-service communication with service discovery\r\nasync function getUser(userId) {\r\n  const userServiceUrl = await discoverService('user-service');\r\n  const response = await axios.get(`${userServiceUrl}/api/users/${userId}`);\r\n  return response.data;\r\n}\r\n\r\n// Event-driven communication (using message queue)\r\nconst amqp = require('amqplib');\r\n\r\n// Publisher (Order Service)\r\nasync function publishOrderCreated(order) {\r\n  const connection = await amqp.connect('amqp://localhost');\r\n  const channel = await connection.createChannel();\r\n  \r\n  await channel.assertQueue('order.created', { durable: true });\r\n  \r\n  channel.sendToQueue('order.created', Buffer.from(JSON.stringify(order)), {\r\n    persistent: true\r\n  });\r\n  \r\n  await channel.close();\r\n  await connection.close();\r\n}\r\n\r\n// Consumer (Email Service)\r\nasync function consumeOrderCreated() {\r\n  const connection = await amqp.connect('amqp://localhost');\r\n  const channel = await connection.createChannel();\r\n  \r\n  await channel.assertQueue('order.created', { durable: true });\r\n  \r\n  channel.consume('order.created', async (msg) => {\r\n    const order = JSON.parse(msg.content.toString());\r\n    \r\n    // Send email notification\r\n    await sendOrderConfirmationEmail(order);\r\n    \r\n    channel.ack(msg);\r\n  });\r\n}\r\n\r\n// Circuit breaker pattern\r\nconst CircuitBreaker = require('opossum');\r\n\r\nconst options = {\r\n  timeout: 3000,\r\n  errorThresholdPercentage: 50,\r\n  resetTimeout: 30000\r\n};\r\n\r\nconst breaker = new CircuitBreaker(callUserService, options);\r\n\r\nasync function callUserService(userId) {\r\n  const response = await axios.get(`http://user-service:3001/api/users/${userId}`);\r\n  return response.data;\r\n}\r\n\r\n// Usage\r\nbreaker.fire(userId)\r\n  .then(result => console.log(result))\r\n  .catch(err => console.error('Service unavailable'));\r\n```",
    "number": 10
  },
  {
    "id": "backend-11",
    "topic": "backend",
    "title": "Explain ACID Transactions: Database Transactions, Transaction Isolation, and Error Handling",
    "answer": "ACID ensures reliable database operations: Atomicity, Consistency, Isolation, Durability.\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\n// MongoDB Transactions (requires replica set)\r\nasync function transferFunds(fromAccountId, toAccountId, amount) {\r\n  const session = await mongoose.startSession();\r\n  session.startTransaction();\r\n  \r\n  try {\r\n    // Atomic operation: both succeed or both fail\r\n    const fromAccount = await Account.findById(fromAccountId).session(session);\r\n    \r\n    if (fromAccount.balance < amount) {\r\n      throw new Error('Insufficient funds');\r\n    }\r\n    \r\n    await Account.updateOne(\r\n      { _id: fromAccountId },\r\n      { $inc: { balance: -amount } },\r\n      { session }\r\n    );\r\n    \r\n    await Account.updateOne(\r\n      { _id: toAccountId },\r\n      { $inc: { balance: amount } },\r\n      { session }\r\n    );\r\n    \r\n    // Create transaction record\r\n    await Transaction.create([{\r\n      fromAccount: fromAccountId,\r\n      toAccount: toAccountId,\r\n      amount,\r\n      type: 'transfer'\r\n    }], { session });\r\n    \r\n    // Commit transaction\r\n    await session.commitTransaction();\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    // Rollback on error\r\n    await session.abortTransaction();\r\n    throw error;\r\n  } finally {\r\n    session.endSession();\r\n  }\r\n}\r\n\r\n// PostgreSQL Transactions (using pg)\r\nconst { Pool } = require('pg');\r\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\r\n\r\nasync function transferFundsPG(fromAccountId, toAccountId, amount) {\r\n  const client = await pool.connect();\r\n  \r\n  try {\r\n    await client.query('BEGIN');\r\n    \r\n    // Check balance\r\n    const fromAccount = await client.query(\r\n      'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',\r\n      [fromAccountId]\r\n    );\r\n    \r\n    if (fromAccount.rows[0].balance < amount) {\r\n      throw new Error('Insufficient funds');\r\n    }\r\n    \r\n    // Debit\r\n    await client.query(\r\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\r\n      [amount, fromAccountId]\r\n    );\r\n    \r\n    // Credit\r\n    await client.query(\r\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\r\n      [amount, toAccountId]\r\n    );\r\n    \r\n    // Create transaction record\r\n    await client.query(\r\n      'INSERT INTO transactions (from_account, to_account, amount, type) VALUES ($1, $2, $3, $4)',\r\n      [fromAccountId, toAccountId, amount, 'transfer']\r\n    );\r\n    \r\n    await client.query('COMMIT');\r\n    return { success: true };\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n// Transaction isolation levels\r\n// READ UNCOMMITTED (lowest isolation, highest concurrency)\r\n// READ COMMITTED (default in PostgreSQL)\r\n// REPEATABLE READ (default in MySQL)\r\n// SERIALIZABLE (highest isolation, lowest concurrency)\r\n\r\n// Using SERIALIZABLE isolation\r\nasync function transferWithIsolation(fromAccountId, toAccountId, amount) {\r\n  const client = await pool.connect();\r\n  \r\n  try {\r\n    await client.query('BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE');\r\n    \r\n    // Perform operations...\r\n    \r\n    await client.query('COMMIT');\r\n  } catch (error) {\r\n    if (error.code === '40001') { // Serialization failure\r\n      // Retry transaction\r\n      return await transferWithIsolation(fromAccountId, toAccountId, amount);\r\n    }\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n// Transaction wrapper utility\r\nasync function withTransaction(callback) {\r\n  const session = await mongoose.startSession();\r\n  session.startTransaction();\r\n  \r\n  try {\r\n    const result = await callback(session);\r\n    await session.commitTransaction();\r\n    return result;\r\n  } catch (error) {\r\n    await session.abortTransaction();\r\n    throw error;\r\n  } finally {\r\n    session.endSession();\r\n  }\r\n}\r\n\r\n// Usage\r\nawait withTransaction(async (session) => {\r\n  await Account.updateOne(\r\n    { _id: fromAccountId },\r\n    { $inc: { balance: -amount } },\r\n    { session }\r\n  );\r\n  \r\n  await Account.updateOne(\r\n    { _id: toAccountId },\r\n    { $inc: { balance: amount } },\r\n    { session }\r\n  );\r\n});\r\n\r\n// Optimistic locking (version field)\r\nconst accountSchema = new mongoose.Schema({\r\n  balance: Number,\r\n  version: { type: Number, default: 0 }\r\n});\r\n\r\nasync function updateAccount(id, updateFn) {\r\n  const account = await Account.findById(id);\r\n  const currentVersion = account.version;\r\n  \r\n  updateFn(account);\r\n  account.version += 1;\r\n  \r\n  const result = await Account.updateOne(\r\n    { _id: id, version: currentVersion },\r\n    { $set: { balance: account.balance, version: account.version } }\r\n  );\r\n  \r\n  if (result.matchedCount === 0) {\r\n    throw new Error('Concurrent modification detected');\r\n  }\r\n}\r\n```",
    "number": 11
  },
  {
    "id": "backend-12",
    "topic": "backend",
    "title": "Explain RBAC (Role-Based Access Control): Roles, Permissions, and Dynamic Authorization",
    "answer": "RBAC controls access based on user roles and permissions.\r\n\r\n```javascript\r\n// Role and Permission Models\r\n// models/Role.js\r\nconst roleSchema = new mongoose.Schema({\r\n  name: { type: String, required: true, unique: true },\r\n  permissions: [{ type: String }],\r\n  description: String\r\n});\r\n\r\n// models/User.js\r\nconst userSchema = new mongoose.Schema({\r\n  email: String,\r\n  role: { type: mongoose.Schema.Types.ObjectId, ref: 'Role' },\r\n  customPermissions: [{ type: String }] // Additional permissions beyond role\r\n});\r\n\r\n// Permission definitions\r\nconst PERMISSIONS = {\r\n  // User permissions\r\n  USER_READ: 'user:read',\r\n  USER_CREATE: 'user:create',\r\n  USER_UPDATE: 'user:update',\r\n  USER_DELETE: 'user:delete',\r\n  \r\n  // Post permissions\r\n  POST_READ: 'post:read',\r\n  POST_CREATE: 'post:create',\r\n  POST_UPDATE: 'post:update',\r\n  POST_DELETE: 'post:delete',\r\n  \r\n  // Admin permissions\r\n  ADMIN_ALL: 'admin:*'\r\n};\r\n\r\n// Default roles\r\nconst DEFAULT_ROLES = {\r\n  ADMIN: {\r\n    name: 'admin',\r\n    permissions: [PERMISSIONS.ADMIN_ALL]\r\n  },\r\n  USER: {\r\n    name: 'user',\r\n    permissions: [PERMISSIONS.USER_READ, PERMISSIONS.POST_READ, PERMISSIONS.POST_CREATE]\r\n  },\r\n  MODERATOR: {\r\n    name: 'moderator',\r\n    permissions: [PERMISSIONS.POST_READ, PERMISSIONS.POST_UPDATE, PERMISSIONS.POST_DELETE]\r\n  }\r\n};\r\n\r\n// Permission check utility\r\nfunction hasPermission(userPermissions, requiredPermission) {\r\n  // Check for admin wildcard\r\n  if (userPermissions.includes(PERMISSIONS.ADMIN_ALL)) {\r\n    return true;\r\n  }\r\n  \r\n  // Exact match\r\n  if (userPermissions.includes(requiredPermission)) {\r\n    return true;\r\n  }\r\n  \r\n  // Wildcard match (e.g., 'user:*' matches 'user:read')\r\n  const [resource, action] = requiredPermission.split(':');\r\n  const wildcardPermission = `${resource}:*`;\r\n  \r\n  return userPermissions.includes(wildcardPermission);\r\n}\r\n\r\n// Permission middleware\r\nfunction requirePermission(permission) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return res.status(401).json({ error: 'Authentication required' });\r\n    }\r\n    \r\n    const user = await User.findById(req.user.userId).populate('role');\r\n    \r\n    if (!user) {\r\n      return res.status(404).json({ error: 'User not found' });\r\n    }\r\n    \r\n    // Get all permissions (role + custom)\r\n    const rolePermissions = user.role?.permissions || [];\r\n    const allPermissions = [...rolePermissions, ...(user.customPermissions || [])];\r\n    \r\n    if (!hasPermission(allPermissions, permission)) {\r\n      return res.status(403).json({ error: 'Insufficient permissions' });\r\n    }\r\n    \r\n    req.userPermissions = allPermissions;\r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.get('/api/users', authenticateToken, requirePermission(PERMISSIONS.USER_READ), getUsers);\r\napp.post('/api/users', authenticateToken, requirePermission(PERMISSIONS.USER_CREATE), createUser);\r\napp.delete('/api/users/:id', authenticateToken, requirePermission(PERMISSIONS.USER_DELETE), deleteUser);\r\n\r\n// Multiple permissions (any one required)\r\nfunction requireAnyPermission(...permissions) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return res.status(401).json({ error: 'Authentication required' });\r\n    }\r\n    \r\n    const user = await User.findById(req.user.userId).populate('role');\r\n    const rolePermissions = user.role?.permissions || [];\r\n    const allPermissions = [...rolePermissions, ...(user.customPermissions || [])];\r\n    \r\n    const hasAnyPermission = permissions.some(permission => \r\n      hasPermission(allPermissions, permission)\r\n    );\r\n    \r\n    if (!hasAnyPermission) {\r\n      return res.status(403).json({ error: 'Insufficient permissions' });\r\n    }\r\n    \r\n    next();\r\n  };\r\n}\r\n\r\n// Resource-based permissions (ownership check)\r\nfunction requireOwnershipOrPermission(resourceModel, permission) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return res.status(401).json({ error: 'Authentication required' });\r\n    }\r\n    \r\n    const Model = require(`../models/${resourceModel}`);\r\n    const resource = await Model.findById(req.params.id);\r\n    \r\n    if (!resource) {\r\n      return res.status(404).json({ error: 'Resource not found' });\r\n    }\r\n    \r\n    // Check ownership\r\n    const isOwner = resource.userId?.toString() === req.user.userId;\r\n    \r\n    // Get user permissions\r\n    const user = await User.findById(req.user.userId).populate('role');\r\n    const rolePermissions = user.role?.permissions || [];\r\n    const allPermissions = [...rolePermissions, ...(user.customPermissions || [])];\r\n    \r\n    // Allow if owner or has permission\r\n    if (!isOwner && !hasPermission(allPermissions, permission)) {\r\n      return res.status(403).json({ error: 'Insufficient permissions' });\r\n    }\r\n    \r\n    req.resource = resource;\r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.put('/api/posts/:id', authenticateToken, requireOwnershipOrPermission('Post', PERMISSIONS.POST_UPDATE), updatePost);\r\n\r\n// Role-based route protection\r\nfunction requireRole(...roles) {\r\n  return async (req, res, next) => {\r\n    if (!req.user) {\r\n      return res.status(401).json({ error: 'Authentication required' });\r\n    }\r\n    \r\n    const user = await User.findById(req.user.userId).populate('role');\r\n    \r\n    if (!user.role || !roles.includes(user.role.name)) {\r\n      return res.status(403).json({ error: 'Insufficient role permissions' });\r\n    }\r\n    \r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.get('/api/admin/stats', authenticateToken, requireRole('admin'), getStats);\r\n```",
    "number": 12
  },
  {
    "id": "backend-13",
    "topic": "backend",
    "title": "Explain RESTful API Design: HTTP Methods, Status Codes, and Best Practices",
    "answer": "REST (Representational State Transfer) is an architectural style for designing web APIs.\r\n\r\n```javascript\r\n// RESTful route design\r\n// GET /api/users - List all users\r\n// GET /api/users/:id - Get single user\r\n// POST /api/users - Create user\r\n// PUT /api/users/:id - Update entire user\r\n// PATCH /api/users/:id - Partial update\r\n// DELETE /api/users/:id - Delete user\r\n\r\n// HTTP Status Codes\r\n// 2xx Success\r\n200 OK - Successful GET/PUT/PATCH\r\n201 Created - Successful POST (resource created)\r\n204 No Content - Successful DELETE (no body)\r\n\r\n// 4xx Client Errors\r\n400 Bad Request - Invalid request data\r\n401 Unauthorized - Missing/invalid authentication\r\n403 Forbidden - Authenticated but no permission\r\n404 Not Found - Resource doesn't exist\r\n409 Conflict - Resource conflict (e.g., duplicate)\r\n422 Unprocessable Entity - Validation errors\r\n\r\n// 5xx Server Errors\r\n500 Internal Server Error - Generic server error\r\n502 Bad Gateway - Invalid response from upstream\r\n503 Service Unavailable - Service temporarily down\r\n\r\n// Route examples\r\napp.get('/api/users', async (req, res) => {\r\n  const users = await User.find();\r\n  res.status(200).json({ users });\r\n});\r\n\r\napp.get('/api/users/:id', async (req, res) => {\r\n  const user = await User.findById(req.params.id);\r\n  if (!user) {\r\n    return res.status(404).json({ error: 'User not found' });\r\n  }\r\n  res.status(200).json({ user });\r\n});\r\n\r\napp.post('/api/users', async (req, res) => {\r\n  const user = await User.create(req.body);\r\n  res.status(201).json({ user });\r\n});\r\n\r\napp.put('/api/users/:id', async (req, res) => {\r\n  const user = await User.findByIdAndUpdate(\r\n    req.params.id,\r\n    req.body,\r\n    { new: true, runValidators: true }\r\n  );\r\n  if (!user) {\r\n    return res.status(404).json({ error: 'User not found' });\r\n  }\r\n  res.status(200).json({ user });\r\n});\r\n\r\napp.delete('/api/users/:id', async (req, res) => {\r\n  const user = await User.findByIdAndDelete(req.params.id);\r\n  if (!user) {\r\n    return res.status(404).json({ error: 'User not found' });\r\n  }\r\n  res.status(204).send();\r\n});\r\n\r\n// Best practices\r\n// 1. Use nouns, not verbs in URLs\r\n// Bad: /api/getUser, /api/createUser\r\n// Good: /api/users, POST /api/users\r\n\r\n// 2. Use plural nouns for collections\r\n// /api/users (not /api/user)\r\n\r\n// 3. Use nested resources for relationships\r\n// GET /api/users/:userId/posts\r\n// POST /api/users/:userId/posts\r\n\r\n// 4. Filtering, sorting, pagination via query params\r\n// GET /api/users?role=admin&sort=-createdAt&page=1&limit=10\r\n\r\n// 5. Consistent response format\r\n{\r\n  \"success\": true,\r\n  \"data\": { /* resource or array */ },\r\n  \"message\": \"Optional message\"\r\n}\r\n\r\n// Error response format\r\n{\r\n  \"success\": false,\r\n  \"error\": {\r\n    \"message\": \"Error description\",\r\n    \"code\": \"ERROR_CODE\",\r\n    \"details\": []\r\n  }\r\n}\r\n```",
    "number": 13
  },
  {
    "id": "backend-14",
    "topic": "backend",
    "title": "Explain CORS (Cross-Origin Resource Sharing) and Security Middleware",
    "answer": "CORS allows controlled access to resources from different origins.\r\n\r\n```javascript\r\nconst cors = require('cors');\r\nconst helmet = require('helmet');\r\nconst express = require('express');\r\nconst app = express();\r\n\r\n// Basic CORS - allow all origins (development only)\r\napp.use(cors());\r\n\r\n// CORS with specific origin\r\napp.use(cors({\r\n  origin: 'https://example.com',\r\n  credentials: true,\r\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\r\n  allowedHeaders: ['Content-Type', 'Authorization']\r\n}));\r\n\r\n// CORS with multiple origins\r\nconst allowedOrigins = [\r\n  'https://example.com',\r\n  'https://www.example.com',\r\n  'http://localhost:3000'\r\n];\r\n\r\napp.use(cors({\r\n  origin: (origin, callback) => {\r\n    if (!origin || allowedOrigins.includes(origin)) {\r\n      callback(null, true);\r\n    } else {\r\n      callback(new Error('Not allowed by CORS'));\r\n    }\r\n  },\r\n  credentials: true\r\n}));\r\n\r\n// Manual CORS middleware\r\napp.use((req, res, next) => {\r\n  res.header('Access-Control-Allow-Origin', 'https://example.com');\r\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\r\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n  res.header('Access-Control-Allow-Credentials', 'true');\r\n  \r\n  // Handle preflight requests\r\n  if (req.method === 'OPTIONS') {\r\n    return res.sendStatus(200);\r\n  }\r\n  \r\n  next();\r\n});\r\n\r\n// Security headers with Helmet\r\napp.use(helmet({\r\n  contentSecurityPolicy: {\r\n    directives: {\r\n      defaultSrc: [\"'self'\"],\r\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\r\n      scriptSrc: [\"'self'\"],\r\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\r\n    }\r\n  },\r\n  crossOriginEmbedderPolicy: false\r\n}));\r\n\r\n// Helmet protects against:\r\n// - XSS attacks\r\n// - Clickjacking\r\n// - MIME-type sniffing\r\n// - Information disclosure\r\n\r\n// XSS protection middleware\r\napp.use((req, res, next) => {\r\n  // Sanitize user input\r\n  if (req.body) {\r\n    Object.keys(req.body).forEach(key => {\r\n      if (typeof req.body[key] === 'string') {\r\n        req.body[key] = req.body[key].replace(/<script[\\s\\S]*?<\\/script>/gi, '');\r\n      }\r\n    });\r\n  }\r\n  next();\r\n});\r\n\r\n// Request size limiting\r\nconst express = require('express');\r\napp.use(express.json({ limit: '10mb' }));\r\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\r\n\r\n// Parameter pollution protection\r\nconst hpp = require('hpp');\r\napp.use(hpp());\r\n\r\n// Rate limiting (basic)\r\nconst rateLimit = require('express-rate-limit');\r\n\r\nconst limiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 100, // Limit each IP to 100 requests per windowMs\r\n  message: 'Too many requests from this IP'\r\n});\r\n\r\napp.use('/api/', limiter);\r\n\r\n// Environment-based CORS\r\nconst corsOptions = {\r\n  origin: process.env.NODE_ENV === 'production'\r\n    ? ['https://example.com']\r\n    : ['http://localhost:3000'],\r\n  credentials: true\r\n};\r\n\r\napp.use(cors(corsOptions));\r\n```",
    "number": 14
  },
  {
    "id": "backend-15",
    "topic": "backend",
    "title": "Explain File Uploads: Multer Configuration, Storage Options, and Image Processing",
    "answer": "File uploads require proper handling for security and performance.\r\n\r\n```javascript\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst sharp = require('sharp'); // Image processing\r\n\r\n// Disk storage configuration\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => {\r\n    const uploadDir = 'uploads/';\r\n    if (!fs.existsSync(uploadDir)) {\r\n      fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n    cb(null, uploadDir);\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n  }\r\n});\r\n\r\n// Memory storage (for processing before saving)\r\nconst memoryStorage = multer.memoryStorage();\r\n\r\n// File filter\r\nconst fileFilter = (req, file, cb) => {\r\n  const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;\r\n  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\r\n  const mimetype = allowedTypes.test(file.mimetype);\r\n  \r\n  if (mimetype && extname) {\r\n    return cb(null, true);\r\n  } else {\r\n    cb(new Error('Invalid file type. Only images and documents allowed.'));\r\n  }\r\n};\r\n\r\n// Configure multer\r\nconst upload = multer({\r\n  storage: memoryStorage,\r\n  limits: {\r\n    fileSize: 5 * 1024 * 1024 // 5MB\r\n  },\r\n  fileFilter\r\n});\r\n\r\n// Single file upload\r\napp.post('/api/upload', upload.single('image'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({ error: 'No file uploaded' });\r\n    }\r\n    \r\n    // Process image with Sharp\r\n    const processedImage = await sharp(req.file.buffer)\r\n      .resize(800, 600, { fit: 'inside' })\r\n      .jpeg({ quality: 80 })\r\n      .toBuffer();\r\n    \r\n    // Save to disk or cloud storage\r\n    const filename = `image-${Date.now()}.jpg`;\r\n    fs.writeFileSync(`uploads/${filename}`, processedImage);\r\n    \r\n    res.json({ filename, url: `/uploads/${filename}` });\r\n  } catch (error) {\r\n    res.status(500).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Multiple files upload\r\napp.post('/api/upload/multiple', upload.array('images', 5), async (req, res) => {\r\n  try {\r\n    const files = req.files;\r\n    const uploadedFiles = [];\r\n    \r\n    for (const file of files) {\r\n      const processedImage = await sharp(file.buffer)\r\n        .resize(800, 600)\r\n        .jpeg({ quality: 80 })\r\n        .toBuffer();\r\n      \r\n      const filename = `image-${Date.now()}-${Math.random()}.jpg`;\r\n      fs.writeFileSync(`uploads/${filename}`, processedImage);\r\n      \r\n      uploadedFiles.push({\r\n        filename,\r\n        url: `/uploads/${filename}`\r\n      });\r\n    }\r\n    \r\n    res.json({ files: uploadedFiles });\r\n  } catch (error) {\r\n    res.status(500).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Cloud storage (AWS S3)\r\nconst AWS = require('aws-sdk');\r\nconst s3 = new AWS.S3({\r\n  accessKeyId: process.env.AWS_ACCESS_KEY_ID,\r\n  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\r\n  region: process.env.AWS_REGION\r\n});\r\n\r\napp.post('/api/upload/s3', upload.single('image'), async (req, res) => {\r\n  try {\r\n    const processedImage = await sharp(req.file.buffer)\r\n      .resize(800, 600)\r\n      .jpeg({ quality: 80 })\r\n      .toBuffer();\r\n    \r\n    const params = {\r\n      Bucket: process.env.S3_BUCKET_NAME,\r\n      Key: `images/${Date.now()}-${req.file.originalname}`,\r\n      Body: processedImage,\r\n      ContentType: 'image/jpeg',\r\n      ACL: 'public-read'\r\n    };\r\n    \r\n    const result = await s3.upload(params).promise();\r\n    \r\n    res.json({ url: result.Location });\r\n  } catch (error) {\r\n    res.status(500).json({ error: error.message });\r\n  }\r\n});\r\n\r\n// Cloudinary integration\r\nconst cloudinary = require('cloudinary').v2;\r\n\r\ncloudinary.config({\r\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n  api_key: process.env.CLOUDINARY_API_KEY,\r\n  api_secret: process.env.CLOUDINARY_API_SECRET\r\n});\r\n\r\napp.post('/api/upload/cloudinary', upload.single('image'), async (req, res) => {\r\n  try {\r\n    const result = await cloudinary.uploader.upload_stream(\r\n      {\r\n        folder: 'uploads',\r\n        transformation: [{ width: 800, height: 600, crop: 'limit' }]\r\n      },\r\n      (error, result) => {\r\n        if (error) return res.status(500).json({ error: error.message });\r\n        res.json({ url: result.secure_url });\r\n      }\r\n    ).end(req.file.buffer);\r\n  } catch (error) {\r\n    res.status(500).json({ error: error.message });\r\n  }\r\n});\r\n```",
    "number": 15
  },
  {
    "id": "backend-16",
    "topic": "backend",
    "title": "Explain Caching Strategies: Redis Caching, Cache Invalidation, and Cache-Aside Pattern",
    "answer": "Caching improves performance by storing frequently accessed data in fast storage.\r\n\r\n```javascript\r\nconst redis = require('redis');\r\nconst client = redis.createClient({\r\n  host: process.env.REDIS_HOST,\r\n  port: process.env.REDIS_PORT,\r\n  password: process.env.REDIS_PASSWORD\r\n});\r\n\r\nclient.connect().catch(console.error);\r\n\r\n// Cache middleware\r\nfunction cacheMiddleware(duration = 3600) {\r\n  return async (req, res, next) => {\r\n    const key = req.originalUrl || req.url;\r\n    \r\n    try {\r\n      const cachedData = await client.get(key);\r\n      \r\n      if (cachedData) {\r\n        return res.json(JSON.parse(cachedData));\r\n      }\r\n      \r\n      // Store original json method\r\n      const originalJson = res.json.bind(res);\r\n      \r\n      // Override json method to cache response\r\n      res.json = function(data) {\r\n        client.setEx(key, duration, JSON.stringify(data));\r\n        return originalJson(data);\r\n      };\r\n      \r\n      next();\r\n    } catch (error) {\r\n      next();\r\n    }\r\n  };\r\n}\r\n\r\n// Usage\r\napp.get('/api/users', cacheMiddleware(300), getUsers);\r\n\r\n// Cache-aside pattern (manual)\r\nasync function getUserWithCache(userId) {\r\n  const cacheKey = `user:${userId}`;\r\n  \r\n  try {\r\n    // Try cache first\r\n    const cached = await client.get(cacheKey);\r\n    if (cached) {\r\n      return JSON.parse(cached);\r\n    }\r\n    \r\n    // Cache miss - fetch from database\r\n    const user = await User.findById(userId);\r\n    \r\n    if (user) {\r\n      // Store in cache\r\n      await client.setEx(cacheKey, 3600, JSON.stringify(user));\r\n    }\r\n    \r\n    return user;\r\n  } catch (error) {\r\n    // On error, fallback to database\r\n    return await User.findById(userId);\r\n  }\r\n}\r\n\r\n// Cache invalidation\r\nasync function updateUser(userId, updateData) {\r\n  const user = await User.findByIdAndUpdate(userId, updateData, { new: true });\r\n  \r\n  // Invalidate cache\r\n  await client.del(`user:${userId}`);\r\n  await client.del('users:list'); // Invalidate list cache\r\n  \r\n  return user;\r\n}\r\n\r\n// Cache with tags (for bulk invalidation)\r\nasync function cacheWithTags(key, data, tags, ttl = 3600) {\r\n  await client.setEx(key, ttl, JSON.stringify(data));\r\n  \r\n  // Store key in tag sets\r\n  for (const tag of tags) {\r\n    await client.sAdd(`tag:${tag}`, key);\r\n    await client.expire(`tag:${tag}`, ttl);\r\n  }\r\n}\r\n\r\n// Invalidate by tag\r\nasync function invalidateByTag(tag) {\r\n  const keys = await client.sMembers(`tag:${tag}`);\r\n  if (keys.length > 0) {\r\n    await client.del(...keys);\r\n    await client.del(`tag:${tag}`);\r\n  }\r\n}\r\n\r\n// Usage\r\nawait cacheWithTags('user:123', userData, ['users', 'user:123'], 3600);\r\nawait invalidateByTag('users'); // Invalidates all user-related cache\r\n\r\n// Cache warming (pre-populate cache)\r\nasync function warmCache() {\r\n  const popularUsers = await User.find({ isPopular: true });\r\n  \r\n  for (const user of popularUsers) {\r\n    await client.setEx(\r\n      `user:${user.id}`,\r\n      3600,\r\n      JSON.stringify(user)\r\n    );\r\n  }\r\n}\r\n\r\n// Cache stampede prevention (mutex)\r\nasync function getUserWithMutex(userId) {\r\n  const cacheKey = `user:${userId}`;\r\n  const mutexKey = `mutex:${cacheKey}`;\r\n  \r\n  try {\r\n    const cached = await client.get(cacheKey);\r\n    if (cached) return JSON.parse(cached);\r\n    \r\n    // Try to acquire lock\r\n    const lock = await client.set(mutexKey, 'locked', {\r\n      EX: 10,\r\n      NX: true\r\n    });\r\n    \r\n    if (lock) {\r\n      // We have the lock - fetch data\r\n      const user = await User.findById(userId);\r\n      await client.setEx(cacheKey, 3600, JSON.stringify(user));\r\n      await client.del(mutexKey);\r\n      return user;\r\n    } else {\r\n      // Wait a bit and retry cache\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n      const cached = await client.get(cacheKey);\r\n      return cached ? JSON.parse(cached) : await User.findById(userId);\r\n    }\r\n  } catch (error) {\r\n    return await User.findById(userId);\r\n  }\r\n}\r\n```",
    "number": 16
  },
  {
    "id": "backend-17",
    "topic": "backend",
    "title": "Explain WebSockets: Socket.io Setup, Real-Time Communication, and Room Management",
    "answer": "WebSockets enable bidirectional real-time communication between client and server.\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst http = require('http');\r\nconst { Server } = require('socket.io');\r\n\r\nconst app = express();\r\nconst server = http.createServer(app);\r\nconst io = new Server(server, {\r\n  cors: {\r\n    origin: \"http://localhost:3000\",\r\n    methods: [\"GET\", \"POST\"]\r\n  }\r\n});\r\n\r\n// Connection handling\r\nio.on('connection', (socket) => {\r\n  console.log('User connected:', socket.id);\r\n  \r\n  // Emit to single client\r\n  socket.emit('welcome', { message: 'Welcome to the server!' });\r\n  \r\n  // Listen for events from client\r\n  socket.on('message', (data) => {\r\n    console.log('Message received:', data);\r\n    \r\n    // Broadcast to all clients except sender\r\n    socket.broadcast.emit('message', data);\r\n    \r\n    // Or emit to all clients including sender\r\n    // io.emit('message', data);\r\n  });\r\n  \r\n  // Join a room\r\n  socket.on('join-room', (roomId) => {\r\n    socket.join(roomId);\r\n    socket.to(roomId).emit('user-joined', { userId: socket.id });\r\n  });\r\n  \r\n  // Leave a room\r\n  socket.on('leave-room', (roomId) => {\r\n    socket.leave(roomId);\r\n    socket.to(roomId).emit('user-left', { userId: socket.id });\r\n  });\r\n  \r\n  // Send to specific room\r\n  socket.on('room-message', ({ roomId, message }) => {\r\n    io.to(roomId).emit('message', message);\r\n  });\r\n  \r\n  // Disconnect handling\r\n  socket.on('disconnect', () => {\r\n    console.log('User disconnected:', socket.id);\r\n  });\r\n});\r\n\r\n// Authentication middleware for Socket.io\r\nio.use((socket, next) => {\r\n  const token = socket.handshake.auth.token;\r\n  \r\n  if (!token) {\r\n    return next(new Error('Authentication error'));\r\n  }\r\n  \r\n  try {\r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n    socket.userId = decoded.userId;\r\n    next();\r\n  } catch (error) {\r\n    next(new Error('Authentication error'));\r\n  }\r\n});\r\n\r\n// Namespace (for different channels)\r\nconst chatNamespace = io.of('/chat');\r\n\r\nchatNamespace.on('connection', (socket) => {\r\n  socket.on('join', (roomId) => {\r\n    socket.join(roomId);\r\n  });\r\n  \r\n  socket.on('send-message', (data) => {\r\n    chatNamespace.to(data.roomId).emit('new-message', data);\r\n  });\r\n});\r\n\r\n// Room management\r\nconst rooms = new Map();\r\n\r\nio.on('connection', (socket) => {\r\n  socket.on('create-room', (roomData) => {\r\n    const roomId = `room-${Date.now()}`;\r\n    rooms.set(roomId, {\r\n      id: roomId,\r\n      ...roomData,\r\n      participants: [socket.userId],\r\n      createdAt: new Date()\r\n    });\r\n    \r\n    socket.join(roomId);\r\n    socket.emit('room-created', { roomId });\r\n  });\r\n  \r\n  socket.on('join-room', (roomId) => {\r\n    const room = rooms.get(roomId);\r\n    if (room) {\r\n      socket.join(roomId);\r\n      room.participants.push(socket.userId);\r\n      \r\n      io.to(roomId).emit('user-joined-room', {\r\n        userId: socket.userId,\r\n        participants: room.participants\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\n// Presence system\r\nconst userSockets = new Map(); // userId -> Set of socketIds\r\n\r\nio.on('connection', (socket) => {\r\n  const userId = socket.userId;\r\n  \r\n  if (!userSockets.has(userId)) {\r\n    userSockets.set(userId, new Set());\r\n  }\r\n  userSockets.get(userId).add(socket.id);\r\n  \r\n  // Notify others that user came online\r\n  socket.broadcast.emit('user-online', { userId });\r\n  \r\n  socket.on('disconnect', () => {\r\n    userSockets.get(userId)?.delete(socket.id);\r\n    \r\n    if (userSockets.get(userId).size === 0) {\r\n      userSockets.delete(userId);\r\n      socket.broadcast.emit('user-offline', { userId });\r\n    }\r\n  });\r\n});\r\n\r\n// Emit to specific user (across all their sockets)\r\nfunction emitToUser(userId, event, data) {\r\n  const sockets = userSockets.get(userId);\r\n  if (sockets) {\r\n    sockets.forEach(socketId => {\r\n      io.to(socketId).emit(event, data);\r\n    });\r\n  }\r\n}\r\n\r\nserver.listen(3000, () => {\r\n  console.log('Server running on port 3000');\r\n});\r\n```",
    "number": 17
  },
  {
    "id": "backend-18",
    "topic": "backend",
    "title": "Explain Database Connection Pooling: MongoDB and PostgreSQL Connection Management",
    "answer": "Connection pooling manages database connections efficiently to reduce overhead.\r\n\r\n```javascript\r\n// MongoDB Connection Pooling (Mongoose)\r\nconst mongoose = require('mongoose');\r\n\r\nconst options = {\r\n  maxPoolSize: 10, // Maintain up to 10 socket connections\r\n  minPoolSize: 2, // Maintain at least 2 socket connections\r\n  socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity\r\n  serverSelectionTimeoutMS: 5000, // How long to try selecting a server\r\n  heartbeatFrequencyMS: 10000, // Heartbeat every 10 seconds\r\n  maxIdleTimeMS: 30000 // Close connections after 30 seconds of inactivity\r\n};\r\n\r\nmongoose.connect(process.env.MONGODB_URI, options);\r\n\r\nconst db = mongoose.connection;\r\n\r\ndb.on('connected', () => {\r\n  console.log('MongoDB connected');\r\n});\r\n\r\ndb.on('error', (err) => {\r\n  console.error('MongoDB connection error:', err);\r\n});\r\n\r\ndb.on('disconnected', () => {\r\n  console.log('MongoDB disconnected');\r\n});\r\n\r\n// PostgreSQL Connection Pooling (pg)\r\nconst { Pool } = require('pg');\r\n\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL,\r\n  max: 20, // Maximum number of clients in the pool\r\n  min: 5, // Minimum number of clients in the pool\r\n  idleTimeoutMillis: 30000, // Close idle clients after 30 seconds\r\n  connectionTimeoutMillis: 2000, // Return error after 2 seconds if connection cannot be established\r\n  statement_timeout: 30000 // Close connections after 30 seconds if query takes too long\r\n});\r\n\r\n// Pool events\r\npool.on('connect', (client) => {\r\n  console.log('New client connected');\r\n});\r\n\r\npool.on('error', (err, client) => {\r\n  console.error('Unexpected error on idle client', err);\r\n  process.exit(-1);\r\n});\r\n\r\n// Using the pool\r\nasync function query(text, params) {\r\n  const client = await pool.connect();\r\n  try {\r\n    const result = await client.query(text, params);\r\n    return result;\r\n  } finally {\r\n    client.release(); // Return client to pool\r\n  }\r\n}\r\n\r\n// Transaction with pool\r\nasync function transaction(callback) {\r\n  const client = await pool.connect();\r\n  try {\r\n    await client.query('BEGIN');\r\n    const result = await callback(client);\r\n    await client.query('COMMIT');\r\n    return result;\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n// Connection pool monitoring\r\nfunction getPoolStats() {\r\n  return {\r\n    totalCount: pool.totalCount,\r\n    idleCount: pool.idleCount,\r\n    waitingCount: pool.waitingCount\r\n  };\r\n}\r\n\r\n// Graceful shutdown\r\nasync function closePool() {\r\n  await pool.end();\r\n  console.log('Pool has ended');\r\n}\r\n\r\nprocess.on('SIGINT', async () => {\r\n  await closePool();\r\n  process.exit(0);\r\n});\r\n\r\n// Connection health check\r\nasync function checkDatabaseHealth() {\r\n  try {\r\n    const result = await pool.query('SELECT NOW()');\r\n    return { status: 'healthy', timestamp: result.rows[0].now };\r\n  } catch (error) {\r\n    return { status: 'unhealthy', error: error.message };\r\n  }\r\n}\r\n\r\n// Connection retry logic\r\nasync function connectWithRetry(maxRetries = 5, delay = 5000) {\r\n  for (let i = 0; i < maxRetries; i++) {\r\n    try {\r\n      await mongoose.connect(process.env.MONGODB_URI);\r\n      console.log('Database connected');\r\n      return;\r\n    } catch (error) {\r\n      console.error(`Connection attempt ${i + 1} failed:`, error.message);\r\n      if (i < maxRetries - 1) {\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n}\r\n```",
    "number": 18
  },
  {
    "id": "backend-19",
    "topic": "backend",
    "title": "Explain Password Hashing: bcrypt, Salt Rounds, and Security Best Practices",
    "answer": "Password hashing prevents storing plain-text passwords and protects against breaches.\r\n\r\n```javascript\r\nconst bcrypt = require('bcrypt');\r\nconst crypto = require('crypto');\r\n\r\n// Hashing password\r\nasync function hashPassword(password) {\r\n  const saltRounds = 12; // Higher = more secure but slower\r\n  const hashedPassword = await bcrypt.hash(password, saltRounds);\r\n  return hashedPassword;\r\n}\r\n\r\n// Comparing password\r\nasync function comparePassword(password, hashedPassword) {\r\n  const isMatch = await bcrypt.compare(password, hashedPassword);\r\n  return isMatch;\r\n}\r\n\r\n// User registration\r\nasync function registerUser(req, res) {\r\n  const { email, password } = req.body;\r\n  \r\n  // Validate password strength\r\n  if (password.length < 8) {\r\n    return res.status(400).json({ error: 'Password must be at least 8 characters' });\r\n  }\r\n  \r\n  // Hash password\r\n  const hashedPassword = await hashPassword(password);\r\n  \r\n  // Store user\r\n  const user = await User.create({\r\n    email,\r\n    password: hashedPassword\r\n  });\r\n  \r\n  res.status(201).json({ user: { id: user.id, email: user.email } });\r\n}\r\n\r\n// User login\r\nasync function loginUser(req, res) {\r\n  const { email, password } = req.body;\r\n  \r\n  const user = await User.findOne({ email });\r\n  if (!user) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  // Compare password\r\n  const isMatch = await comparePassword(password, user.password);\r\n  if (!isMatch) {\r\n    return res.status(401).json({ error: 'Invalid credentials' });\r\n  }\r\n  \r\n  // Generate token\r\n  const token = generateToken(user.id);\r\n  res.json({ token, user: { id: user.id, email: user.email } });\r\n}\r\n\r\n// Password strength validation\r\nfunction validatePasswordStrength(password) {\r\n  const minLength = 8;\r\n  const hasUpperCase = /[A-Z]/.test(password);\r\n  const hasLowerCase = /[a-z]/.test(password);\r\n  const hasNumbers = /[0-9]/.test(password);\r\n  const hasSpecialChar = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\r\n  \r\n  const errors = [];\r\n  \r\n  if (password.length < minLength) {\r\n    errors.push(`Password must be at least ${minLength} characters`);\r\n  }\r\n  if (!hasUpperCase) {\r\n    errors.push('Password must contain at least one uppercase letter');\r\n  }\r\n  if (!hasLowerCase) {\r\n    errors.push('Password must contain at least one lowercase letter');\r\n  }\r\n  if (!hasNumbers) {\r\n    errors.push('Password must contain at least one number');\r\n  }\r\n  if (!hasSpecialChar) {\r\n    errors.push('Password must contain at least one special character');\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  };\r\n}\r\n\r\n// Password reset token\r\nasync function generatePasswordResetToken() {\r\n  const token = crypto.randomBytes(32).toString('hex');\r\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\r\n  const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes\r\n  \r\n  return { token, hashedToken, expiresAt };\r\n}\r\n\r\n// Using Argon2 (alternative to bcrypt)\r\nconst argon2 = require('argon2');\r\n\r\nasync function hashPasswordArgon2(password) {\r\n  return await argon2.hash(password, {\r\n    type: argon2.argon2id,\r\n    memoryCost: 2 ** 16, // 64 MB\r\n    timeCost: 3, // 3 iterations\r\n    parallelism: 1\r\n  });\r\n}\r\n\r\nasync function verifyPasswordArgon2(password, hash) {\r\n  return await argon2.verify(hash, password);\r\n}\r\n\r\n// Pre-hash with SHA-256 before bcrypt (optional, for very long passwords)\r\nfunction preHashPassword(password) {\r\n  return crypto.createHash('sha256').update(password).digest('hex');\r\n}\r\n\r\n// Password update\r\nasync function updatePassword(userId, currentPassword, newPassword) {\r\n  const user = await User.findById(userId);\r\n  \r\n  // Verify current password\r\n  const isMatch = await comparePassword(currentPassword, user.password);\r\n  if (!isMatch) {\r\n    throw new Error('Current password is incorrect');\r\n  }\r\n  \r\n  // Validate new password\r\n  const validation = validatePasswordStrength(newPassword);\r\n  if (!validation.isValid) {\r\n    throw new Error(validation.errors.join(', '));\r\n  }\r\n  \r\n  // Hash and update\r\n  const hashedPassword = await hashPassword(newPassword);\r\n  user.password = hashedPassword;\r\n  await user.save();\r\n  \r\n  return user;\r\n}\r\n```",
    "number": 19
  },
  {
    "id": "backend-20",
    "topic": "backend",
    "title": "Explain Rate Limiting: Token Bucket, Sliding Window, and Distributed Rate Limiting",
    "answer": "Rate limiting prevents abuse and ensures fair resource usage.\r\n\r\n```javascript\r\nconst rateLimit = require('express-rate-limit');\r\nconst RedisStore = require('rate-limit-redis');\r\nconst redis = require('redis');\r\n\r\nconst redisClient = redis.createClient();\r\n\r\n// Basic rate limiting\r\nconst limiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 100, // Limit each IP to 100 requests per windowMs\r\n  message: 'Too many requests from this IP, please try again later',\r\n  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers\r\n  legacyHeaders: false\r\n});\r\n\r\napp.use('/api/', limiter);\r\n\r\n// Redis-based rate limiting (for distributed systems)\r\nconst redisLimiter = rateLimit({\r\n  store: new RedisStore({\r\n    client: redisClient,\r\n    prefix: 'rl:'\r\n  }),\r\n  windowMs: 15 * 60 * 1000,\r\n  max: 100\r\n});\r\n\r\n// Different limits for different routes\r\nconst authLimiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000,\r\n  max: 5, // 5 login attempts per 15 minutes\r\n  message: 'Too many login attempts, please try again later',\r\n  skipSuccessfulRequests: true\r\n});\r\n\r\nconst apiLimiter = rateLimit({\r\n  windowMs: 60 * 1000, // 1 minute\r\n  max: 60 // 60 requests per minute\r\n});\r\n\r\napp.post('/api/login', authLimiter, login);\r\napp.use('/api/', apiLimiter);\r\n\r\n// Custom rate limiting based on user\r\nconst userLimiter = rateLimit({\r\n  windowMs: 60 * 1000,\r\n  max: (req) => {\r\n    // Premium users get higher limits\r\n    if (req.user?.isPremium) return 200;\r\n    return 60;\r\n  },\r\n  keyGenerator: (req) => {\r\n    return req.user?.id || req.ip;\r\n  }\r\n});\r\n\r\n// Token bucket algorithm (custom implementation)\r\nclass TokenBucket {\r\n  constructor(capacity, refillRate) {\r\n    this.capacity = capacity;\r\n    this.tokens = capacity;\r\n    this.refillRate = refillRate;\r\n    this.lastRefill = Date.now();\r\n  }\r\n  \r\n  refill() {\r\n    const now = Date.now();\r\n    const elapsed = (now - this.lastRefill) / 1000;\r\n    this.tokens = Math.min(\r\n      this.capacity,\r\n      this.tokens + elapsed * this.refillRate\r\n    );\r\n    this.lastRefill = now;\r\n  }\r\n  \r\n  consume(tokens = 1) {\r\n    this.refill();\r\n    if (this.tokens >= tokens) {\r\n      this.tokens -= tokens;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// Sliding window rate limiter (Redis)\r\nasync function slidingWindowLimiter(userId, limit, windowMs) {\r\n  const key = `rate-limit:${userId}`;\r\n  const now = Date.now();\r\n  const windowStart = now - windowMs;\r\n  \r\n  // Remove old entries\r\n  await redisClient.zRemRangeByScore(key, 0, windowStart);\r\n  \r\n  // Count requests in window\r\n  const count = await redisClient.zCard(key);\r\n  \r\n  if (count < limit) {\r\n    // Add current request\r\n    await redisClient.zAdd(key, { score: now, value: `${now}-${Math.random()}` });\r\n    await redisClient.expire(key, Math.ceil(windowMs / 1000));\r\n    return { allowed: true, remaining: limit - count - 1 };\r\n  }\r\n  \r\n  return { allowed: false, remaining: 0 };\r\n}\r\n\r\n// Rate limit middleware factory\r\nfunction createRateLimiter(options) {\r\n  return async (req, res, next) => {\r\n    const key = options.keyGenerator ? options.keyGenerator(req) : req.ip;\r\n    const result = await slidingWindowLimiter(key, options.max, options.windowMs);\r\n    \r\n    res.setHeader('X-RateLimit-Limit', options.max);\r\n    res.setHeader('X-RateLimit-Remaining', result.remaining);\r\n    \r\n    if (!result.allowed) {\r\n      return res.status(429).json({\r\n        error: 'Too many requests',\r\n        retryAfter: Math.ceil(options.windowMs / 1000)\r\n      });\r\n    }\r\n    \r\n    next();\r\n  };\r\n}\r\n\r\n// Usage\r\napp.use('/api/', createRateLimiter({\r\n  max: 100,\r\n  windowMs: 60 * 1000,\r\n  keyGenerator: (req) => req.user?.id || req.ip\r\n}));\r\n```",
    "number": 20
  },
  {
    "id": "backend-21",
    "topic": "backend",
    "title": "Explain API Documentation: Swagger/OpenAPI Setup, Schema Definition, and Interactive Docs",
    "answer": "API documentation helps developers understand and consume APIs effectively.\r\n\r\n```javascript\r\nconst swaggerJsdoc = require('swagger-jsdoc');\r\nconst swaggerUi = require('swagger-ui-express');\r\n\r\n// Swagger configuration\r\nconst swaggerOptions = {\r\n  definition: {\r\n    openapi: '3.0.0',\r\n    info: {\r\n      title: 'My API',\r\n      version: '1.0.0',\r\n      description: 'API documentation',\r\n      contact: {\r\n        name: 'API Support',\r\n        email: 'support@example.com'\r\n      }\r\n    },\r\n    servers: [\r\n      {\r\n        url: 'http://localhost:3000',\r\n        description: 'Development server'\r\n      },\r\n      {\r\n        url: 'https://api.example.com',\r\n        description: 'Production server'\r\n      }\r\n    ],\r\n    components: {\r\n      securitySchemes: {\r\n        bearerAuth: {\r\n          type: 'http',\r\n          scheme: 'bearer',\r\n          bearerFormat: 'JWT'\r\n        }\r\n      },\r\n      schemas: {\r\n        User: {\r\n          type: 'object',\r\n          properties: {\r\n            id: { type: 'string', example: '507f1f77bcf86cd799439011' },\r\n            email: { type: 'string', example: 'user@example.com' },\r\n            name: { type: 'string', example: 'John Doe' },\r\n            role: { type: 'string', enum: ['user', 'admin'], example: 'user' },\r\n            createdAt: { type: 'string', format: 'date-time' }\r\n          }\r\n        },\r\n        Error: {\r\n          type: 'object',\r\n          properties: {\r\n            error: { type: 'string' },\r\n            message: { type: 'string' }\r\n          }\r\n        }\r\n      }\r\n    },\r\n    security: [{\r\n      bearerAuth: []\r\n    }]\r\n  },\r\n  apis: ['./routes/*.js', './app.js'] // Path to API files\r\n};\r\n\r\nconst swaggerSpec = swaggerJsdoc(swaggerOptions);\r\n\r\n// Serve Swagger UI\r\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));\r\n\r\n// JSDoc annotations in routes\r\n/**\r\n * @swagger\r\n * /api/users:\r\n *   get:\r\n *     summary: Get all users\r\n *     tags: [Users]\r\n *     parameters:\r\n *       - in: query\r\n *         name: page\r\n *         schema:\r\n *           type: integer\r\n *           default: 1\r\n *         description: Page number\r\n *       - in: query\r\n *         name: limit\r\n *         schema:\r\n *           type: integer\r\n *           default: 10\r\n *         description: Items per page\r\n *     responses:\r\n *       200:\r\n *         description: List of users\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 users:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/User'\r\n *       401:\r\n *         $ref: '#/components/responses/Unauthorized'\r\n */\r\napp.get('/api/users', getUsers);\r\n\r\n/**\r\n * @swagger\r\n * /api/users:\r\n *   post:\r\n *     summary: Create a new user\r\n *     tags: [Users]\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         application/json:\r\n *           schema:\r\n *             type: object\r\n *             required:\r\n *               - email\r\n *               - password\r\n *             properties:\r\n *               email:\r\n *                 type: string\r\n *                 format: email\r\n *               password:\r\n *                 type: string\r\n *                 format: password\r\n *               name:\r\n *                 type: string\r\n *     responses:\r\n *       201:\r\n *         description: User created successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/User'\r\n *       400:\r\n *         description: Validation error\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/Error'\r\n */\r\napp.post('/api/users', createUser);\r\n\r\n/**\r\n * @swagger\r\n * /api/users/{id}:\r\n *   get:\r\n *     summary: Get user by ID\r\n *     tags: [Users]\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         schema:\r\n *           type: string\r\n *         description: User ID\r\n *     responses:\r\n *       200:\r\n *         description: User details\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/User'\r\n *       404:\r\n *         description: User not found\r\n */\r\napp.get('/api/users/:id', authenticateToken, getUserById);\r\n\r\n// Reusable response definitions\r\nconst responses = {\r\n  Unauthorized: {\r\n    description: 'Unauthorized',\r\n    content: {\r\n      'application/json': {\r\n        schema: { $ref: '#/components/schemas/Error' }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Generate OpenAPI spec programmatically\r\nconst openApiSpec = {\r\n  openapi: '3.0.0',\r\n  info: {\r\n    title: 'My API',\r\n    version: '1.0.0'\r\n  },\r\n  paths: {\r\n    '/api/users': {\r\n      get: {\r\n        summary: 'Get all users',\r\n        responses: {\r\n          '200': {\r\n            description: 'Success'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n```",
    "number": 21
  },
  {
    "id": "backend-22",
    "topic": "backend",
    "title": "Explain Environment Configuration: dotenv, Environment Variables, and Secrets Management",
    "answer": "Environment configuration separates config from code for security and flexibility.\r\n\r\n```javascript\r\nrequire('dotenv').config();\r\n\r\n// .env file\r\n// NODE_ENV=production\r\n// PORT=3000\r\n// DATABASE_URL=mongodb://localhost:27017/myapp\r\n// JWT_SECRET=your-secret-key\r\n// REDIS_HOST=localhost\r\n// REDIS_PORT=6379\r\n\r\n// Access environment variables\r\nconst PORT = process.env.PORT || 3000;\r\nconst NODE_ENV = process.env.NODE_ENV || 'development';\r\n\r\n// Configuration object\r\nconst config = {\r\n  env: process.env.NODE_ENV || 'development',\r\n  port: parseInt(process.env.PORT || '3000', 10),\r\n  database: {\r\n    url: process.env.DATABASE_URL,\r\n    options: {\r\n      useNewUrlParser: true,\r\n      useUnifiedTopology: true\r\n    }\r\n  },\r\n  jwt: {\r\n    secret: process.env.JWT_SECRET,\r\n    expiresIn: process.env.JWT_EXPIRES_IN || '15m',\r\n    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d'\r\n  },\r\n  redis: {\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: parseInt(process.env.REDIS_PORT || '6379', 10),\r\n    password: process.env.REDIS_PASSWORD\r\n  },\r\n  stripe: {\r\n    secretKey: process.env.STRIPE_SECRET_KEY,\r\n    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET\r\n  }\r\n};\r\n\r\n// Validate required environment variables\r\nfunction validateEnv() {\r\n  const required = ['DATABASE_URL', 'JWT_SECRET'];\r\n  const missing = required.filter(key => !process.env[key]);\r\n  \r\n  if (missing.length > 0) {\r\n    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\r\n  }\r\n}\r\n\r\nvalidateEnv();\r\n\r\n// Environment-specific configs\r\nconst configs = {\r\n  development: {\r\n    logLevel: 'debug',\r\n    corsOrigin: ['http://localhost:3000'],\r\n    database: {\r\n      url: 'mongodb://localhost:27017/myapp-dev'\r\n    }\r\n  },\r\n  production: {\r\n    logLevel: 'error',\r\n    corsOrigin: ['https://example.com'],\r\n    database: {\r\n      url: process.env.DATABASE_URL,\r\n      ssl: true\r\n    }\r\n  },\r\n  test: {\r\n    logLevel: 'silent',\r\n    corsOrigin: [],\r\n    database: {\r\n      url: 'mongodb://localhost:27017/myapp-test'\r\n    }\r\n  }\r\n};\r\n\r\nconst envConfig = configs[process.env.NODE_ENV || 'development'];\r\nconst finalConfig = { ...config, ...envConfig };\r\n\r\n// Secrets management with AWS Secrets Manager\r\nconst AWS = require('aws-sdk');\r\nconst secretsManager = new AWS.SecretsManager();\r\n\r\nasync function getSecret(secretName) {\r\n  try {\r\n    const data = await secretsManager.getSecretValue({ SecretId: secretName }).promise();\r\n    return JSON.parse(data.SecretString);\r\n  } catch (error) {\r\n    console.error('Error retrieving secret:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Load secrets at startup\r\nlet secrets;\r\nasync function loadSecrets() {\r\n  if (process.env.NODE_ENV === 'production') {\r\n    secrets = await getSecret('myapp/secrets');\r\n  } else {\r\n    // Use .env file in development\r\n    require('dotenv').config();\r\n    secrets = {\r\n      jwtSecret: process.env.JWT_SECRET,\r\n      databaseUrl: process.env.DATABASE_URL\r\n    };\r\n  }\r\n}\r\n\r\n// Using config package\r\nconst configPackage = require('config');\r\n\r\n// config/default.json\r\n// {\r\n//   \"server\": {\r\n//     \"port\": 3000\r\n//   },\r\n//   \"database\": {\r\n//     \"url\": \"mongodb://localhost:27017/myapp\"\r\n//   }\r\n// }\r\n\r\n// config/production.json (overrides default.json)\r\n// {\r\n//   \"database\": {\r\n//     \"url\": \"mongodb://production-server:27017/myapp\"\r\n//   }\r\n// }\r\n\r\n    const serverPort = configPackage.get('server.port');\r\nconst dbUrl = configPackage.get('database.url');\r\n```",
    "number": 22
  },
  {
    "id": "backend-23",
    "topic": "backend",
    "title": "Explain Logging and Monitoring: Winston, Morgan, Error Tracking, and Application Monitoring",
    "answer": "Logging and monitoring help track application behavior, debug issues, and monitor performance.\r\n\r\n```javascript\r\nconst winston = require('winston');\r\nconst morgan = require('morgan');\r\n\r\n// Winston logger configuration\r\nconst logger = winston.createLogger({\r\n  level: process.env.LOG_LEVEL || 'info',\r\n  format: winston.format.combine(\r\n    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),\r\n    winston.format.errors({ stack: true }),\r\n    winston.format.json()\r\n  ),\r\n  defaultMeta: { service: 'user-service' },\r\n  transports: [\r\n    // Write all logs to console\r\n    new winston.transports.Console({\r\n      format: winston.format.combine(\r\n        winston.format.colorize(),\r\n        winston.format.simple()\r\n      )\r\n    }),\r\n    // Write errors to error.log\r\n    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\r\n    // Write all logs to combined.log\r\n    new winston.transports.File({ filename: 'logs/combined.log' })\r\n  ]\r\n});\r\n\r\n// If not in production, log to console with simple format\r\nif (process.env.NODE_ENV !== 'production') {\r\n  logger.add(new winston.transports.Console({\r\n    format: winston.format.simple()\r\n  }));\r\n}\r\n\r\n// Logging levels\r\nlogger.error('Error message', { error: err });\r\nlogger.warn('Warning message');\r\nlogger.info('Info message', { userId: 123 });\r\nlogger.http('HTTP request');\r\nlogger.verbose('Verbose message');\r\nlogger.debug('Debug message');\r\nlogger.silly('Silly message');\r\n\r\n// HTTP request logging with Morgan\r\nconst morgan = require('morgan');\r\n\r\n// Combined format (Apache combined log format)\r\napp.use(morgan('combined'));\r\n\r\n// Short format\r\napp.use(morgan('short'));\r\n\r\n// Custom format\r\napp.use(morgan(':method :url :status :response-time ms'));\r\n\r\n// Custom token\r\nmorgan.token('userId', (req) => req.user?.id || 'anonymous');\r\napp.use(morgan(':method :url :status :userId :response-time ms'));\r\n\r\n// Write to file\r\nconst fs = require('fs');\r\nconst accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' });\r\napp.use(morgan('combined', { stream: accessLogStream }));\r\n\r\n// Conditional logging\r\napp.use(morgan('combined', {\r\n  skip: (req, res) => res.statusCode < 400\r\n}));\r\n\r\n// Structured logging with context\r\nfunction logRequest(req, res, next) {\r\n  logger.info('HTTP Request', {\r\n    method: req.method,\r\n    url: req.url,\r\n    ip: req.ip,\r\n    userId: req.user?.id,\r\n    userAgent: req.get('user-agent')\r\n  });\r\n  next();\r\n}\r\n\r\n// Error logging\r\napp.use((err, req, res, next) => {\r\n  logger.error('Unhandled error', {\r\n    error: err.message,\r\n    stack: err.stack,\r\n    url: req.url,\r\n    method: req.method,\r\n    userId: req.user?.id,\r\n    body: req.body,\r\n    params: req.params\r\n  });\r\n  \r\n  res.status(500).json({ error: 'Internal server error' });\r\n});\r\n\r\n// Performance logging\r\nfunction logPerformance(fn, name) {\r\n  return async (req, res, next) => {\r\n    const start = Date.now();\r\n    \r\n    try {\r\n      await fn(req, res, next);\r\n      const duration = Date.now() - start;\r\n      \r\n      if (duration > 1000) {\r\n        logger.warn('Slow operation', { name, duration, url: req.url });\r\n      }\r\n    } catch (error) {\r\n      const duration = Date.now() - start;\r\n      logger.error('Operation failed', { name, duration, error: error.message });\r\n      throw error;\r\n    }\r\n  };\r\n}\r\n\r\n// Log rotation with winston-daily-rotate-file\r\nconst DailyRotateFile = require('winston-daily-rotate-file');\r\n\r\nconst dailyRotateTransport = new DailyRotateFile({\r\n  filename: 'logs/application-%DATE%.log',\r\n  datePattern: 'YYYY-MM-DD',\r\n  maxSize: '20m',\r\n  maxFiles: '14d',\r\n  zippedArchive: true\r\n});\r\n\r\nlogger.add(dailyRotateTransport);\r\n\r\n// Error tracking with Sentry\r\nconst Sentry = require('@sentry/node');\r\n\r\nSentry.init({\r\n  dsn: process.env.SENTRY_DSN,\r\n  environment: process.env.NODE_ENV,\r\n  tracesSampleRate: 1.0\r\n});\r\n\r\n// Capture exceptions\r\napp.use(Sentry.Handlers.requestHandler());\r\napp.use(Sentry.Handlers.errorHandler());\r\n\r\n// Manual error capture\r\ntry {\r\n  // Code that might throw\r\n} catch (error) {\r\n  Sentry.captureException(error);\r\n}\r\n\r\n// Application monitoring\r\nconst prometheus = require('prom-client');\r\n\r\n// Create metrics\r\nconst httpRequestDuration = new prometheus.Histogram({\r\n  name: 'http_request_duration_seconds',\r\n  help: 'Duration of HTTP requests in seconds',\r\n  labelNames: ['method', 'route', 'status_code']\r\n});\r\n\r\nconst httpRequestsTotal = new prometheus.Counter({\r\n  name: 'http_requests_total',\r\n  help: 'Total number of HTTP requests',\r\n  labelNames: ['method', 'route', 'status_code']\r\n});\r\n\r\n// Middleware to collect metrics\r\napp.use((req, res, next) => {\r\n  const start = Date.now();\r\n  \r\n  res.on('finish', () => {\r\n    const duration = (Date.now() - start) / 1000;\r\n    httpRequestDuration.labels(req.method, req.route?.path || req.path, res.statusCode).observe(duration);\r\n    httpRequestsTotal.labels(req.method, req.route?.path || req.path, res.statusCode).inc();\r\n  });\r\n  \r\n  next();\r\n});\r\n\r\n// Expose metrics endpoint\r\napp.get('/metrics', async (req, res) => {\r\n  res.set('Content-Type', prometheus.register.contentType);\r\n  res.end(await prometheus.register.metrics());\r\n});\r\n```",
    "number": 23
  },
  {
    "id": "backend-24",
    "topic": "backend",
    "title": "Explain Background Jobs and Task Queues: Bull/BullMQ, Job Processing, and Priority Queues",
    "answer": "Background jobs handle time-consuming tasks asynchronously without blocking the main request.\r\n\r\n```javascript\r\nconst Queue = require('bull');\r\nconst redis = require('redis');\r\n\r\n// Create queue\r\nconst emailQueue = new Queue('email', {\r\n  redis: {\r\n    host: process.env.REDIS_HOST,\r\n    port: process.env.REDIS_PORT,\r\n    password: process.env.REDIS_PASSWORD\r\n  },\r\n  defaultJobOptions: {\r\n    attempts: 3,\r\n    backoff: {\r\n      type: 'exponential',\r\n      delay: 2000\r\n    },\r\n    removeOnComplete: 100, // Keep last 100 completed jobs\r\n    removeOnFail: 50 // Keep last 50 failed jobs\r\n  }\r\n});\r\n\r\n// Job processor (worker)\r\nemailQueue.process('send-email', async (job) => {\r\n  const { to, subject, body } = job.data;\r\n  \r\n  // Update job progress\r\n  job.progress(50);\r\n  \r\n  // Send email\r\n  await sendEmail(to, subject, body);\r\n  \r\n  job.progress(100);\r\n  \r\n  return { success: true, messageId: '123' };\r\n});\r\n\r\n// Add job to queue\r\nasync function sendEmailJob(emailData) {\r\n  const job = await emailQueue.add('send-email', emailData, {\r\n    priority: 1, // Higher priority (1 = highest)\r\n    delay: 5000, // Delay 5 seconds\r\n    attempts: 5,\r\n    removeOnComplete: true\r\n  });\r\n  \r\n  return job.id;\r\n}\r\n\r\n// Job events\r\nemailQueue.on('completed', (job, result) => {\r\n  console.log(`Job ${job.id} completed with result:`, result);\r\n});\r\n\r\nemailQueue.on('failed', (job, err) => {\r\n  console.error(`Job ${job.id} failed:`, err);\r\n});\r\n\r\nemailQueue.on('progress', (job, progress) => {\r\n  console.log(`Job ${job.id} progress: ${progress}%`);\r\n});\r\n\r\n// Priority queues\r\nconst priorityQueue = new Queue('priority-queue', {\r\n  redis: { host: 'localhost', port: 6379 },\r\n  settings: {\r\n    stalledInterval: 30000,\r\n    maxStalledCount: 1\r\n  }\r\n});\r\n\r\n// Add jobs with different priorities\r\nawait priorityQueue.add('high-priority-job', { data: 'important' }, { priority: 1 });\r\nawait priorityQueue.add('low-priority-job', { data: 'normal' }, { priority: 10 });\r\n\r\n// Scheduled jobs (cron)\r\nconst scheduledQueue = new Queue('scheduled', {\r\n  redis: { host: 'localhost', port: 6379 }\r\n});\r\n\r\n// Add recurring job\r\nawait scheduledQueue.add('daily-report', {}, {\r\n  repeat: {\r\n    cron: '0 0 * * *' // Every day at midnight\r\n  }\r\n});\r\n\r\n// Multiple job types in one queue\r\nconst workerQueue = new Queue('worker', {\r\n  redis: { host: 'localhost', port: 6379 }\r\n});\r\n\r\n// Process different job types\r\nworkerQueue.process('process-image', 5, async (job) => {\r\n  // Process image (5 concurrent jobs)\r\n  return await processImage(job.data);\r\n});\r\n\r\nworkerQueue.process('send-notification', 10, async (job) => {\r\n  // Send notification (10 concurrent jobs)\r\n  return await sendNotification(job.data);\r\n});\r\n\r\n// Job data validation\r\nconst Joi = require('joi');\r\n\r\nconst emailSchema = Joi.object({\r\n  to: Joi.string().email().required(),\r\n  subject: Joi.string().required(),\r\n  body: Joi.string().required()\r\n});\r\n\r\nemailQueue.process('send-email', async (job) => {\r\n  const { error, value } = emailSchema.validate(job.data);\r\n  if (error) {\r\n    throw new Error(`Invalid job data: ${error.message}`);\r\n  }\r\n  \r\n  return await sendEmail(value);\r\n});\r\n\r\n// Job retry with exponential backoff\r\nemailQueue.process('send-email', async (job) => {\r\n  try {\r\n    return await sendEmail(job.data);\r\n  } catch (error) {\r\n    // Job will be retried automatically based on job options\r\n    throw error;\r\n  }\r\n});\r\n\r\n// Get job status\r\nasync function getJobStatus(jobId) {\r\n  const job = await emailQueue.getJob(jobId);\r\n  \r\n  if (!job) {\r\n    return { status: 'not_found' };\r\n  }\r\n  \r\n  const state = await job.getState();\r\n  const progress = job.progress();\r\n  \r\n  return {\r\n    id: job.id,\r\n    status: state,\r\n    progress,\r\n    data: job.data,\r\n    result: job.returnvalue,\r\n    failedReason: job.failedReason\r\n  };\r\n}\r\n\r\n// Cancel job\r\nasync function cancelJob(jobId) {\r\n  const job = await emailQueue.getJob(jobId);\r\n  if (job) {\r\n    await job.remove();\r\n  }\r\n}\r\n\r\n// Pause/Resume queue\r\nawait emailQueue.pause();\r\nawait emailQueue.resume();\r\n\r\n// Clean queue (remove completed/failed jobs)\r\nawait emailQueue.clean(5000, 'completed'); // Remove completed jobs older than 5 seconds\r\nawait emailQueue.clean(86400000, 'failed'); // Remove failed jobs older than 24 hours\r\n\r\n// Queue monitoring\r\nasync function getQueueStats() {\r\n  const [waiting, active, completed, failed, delayed] = await Promise.all([\r\n    emailQueue.getWaitingCount(),\r\n    emailQueue.getActiveCount(),\r\n    emailQueue.getCompletedCount(),\r\n    emailQueue.getFailedCount(),\r\n    emailQueue.getDelayedCount()\r\n  ]);\r\n  \r\n  return { waiting, active, completed, failed, delayed };\r\n}\r\n\r\n// Using BullMQ (newer version)\r\nconst { Queue: BullMQ, Worker } = require('bullmq');\r\n\r\nconst myQueue = new BullMQ('my-queue', {\r\n  connection: {\r\n    host: 'localhost',\r\n    port: 6379\r\n  }\r\n});\r\n\r\nconst worker = new Worker('my-queue', async (job) => {\r\n  // Process job\r\n  return await processJob(job.data);\r\n}, {\r\n  connection: {\r\n    host: 'localhost',\r\n    port: 6379\r\n  },\r\n  concurrency: 5\r\n});\r\n\r\n// Add job\r\nawait myQueue.add('job-name', { data: 'value' });\r\n```",
    "number": 24
  },
  {
    "id": "backend-25",
    "topic": "backend",
    "title": "Explain Testing: Unit Tests, Integration Tests, and E2E Testing with Jest and Supertest",
    "answer": "Testing ensures code quality, prevents regressions, and documents expected behavior.\r\n\r\n```javascript\r\n// Unit Testing with Jest\r\n// __tests__/userService.test.js\r\nconst userService = require('../services/userService');\r\nconst userRepository = require('../repositories/userRepository');\r\n\r\njest.mock('../repositories/userRepository');\r\n\r\ndescribe('UserService', () => {\r\n  beforeEach(() => {\r\n    jest.clearAllMocks();\r\n  });\r\n  \r\n  describe('getUserById', () => {\r\n    it('should return user when found', async () => {\r\n      const mockUser = { id: '1', email: 'test@example.com' };\r\n      userRepository.findById.mockResolvedValue(mockUser);\r\n      \r\n      const result = await userService.getUserById('1');\r\n      \r\n      expect(result).toEqual(mockUser);\r\n      expect(userRepository.findById).toHaveBeenCalledWith('1');\r\n    });\r\n    \r\n    it('should throw error when user not found', async () => {\r\n      userRepository.findById.mockResolvedValue(null);\r\n      \r\n      await expect(userService.getUserById('1')).rejects.toThrow('User not found');\r\n    });\r\n  });\r\n  \r\n  describe('createUser', () => {\r\n    it('should create user with hashed password', async () => {\r\n      const userData = { email: 'test@example.com', password: 'password123' };\r\n      const mockUser = { id: '1', ...userData };\r\n      \r\n      userRepository.findByEmail.mockResolvedValue(null);\r\n      userRepository.create.mockResolvedValue(mockUser);\r\n      \r\n      const result = await userService.createUser(userData);\r\n      \r\n      expect(userRepository.create).toHaveBeenCalled();\r\n      expect(result.password).not.toBe(userData.password); // Password should be hashed\r\n    });\r\n  });\r\n});\r\n\r\n// Integration Testing with Supertest\r\n// __tests__/routes/userRoutes.test.js\r\nconst request = require('supertest');\r\nconst app = require('../../app');\r\nconst User = require('../../models/User');\r\nconst { connectDB, disconnectDB } = require('../../config/database');\r\n\r\ndescribe('User Routes', () => {\r\n  beforeAll(async () => {\r\n    await connectDB();\r\n  });\r\n  \r\n  afterAll(async () => {\r\n    await disconnectDB();\r\n  });\r\n  \r\n  beforeEach(async () => {\r\n    await User.deleteMany({});\r\n  });\r\n  \r\n  describe('POST /api/users', () => {\r\n    it('should create a new user', async () => {\r\n      const userData = {\r\n        email: 'test@example.com',\r\n        password: 'password123'\r\n      };\r\n      \r\n      const response = await request(app)\r\n        .post('/api/users')\r\n        .send(userData)\r\n        .expect(201);\r\n      \r\n      expect(response.body.user).toHaveProperty('id');\r\n      expect(response.body.user.email).toBe(userData.email);\r\n      expect(response.body.user.password).toBeUndefined();\r\n    });\r\n    \r\n    it('should return 400 if email is missing', async () => {\r\n      const response = await request(app)\r\n        .post('/api/users')\r\n        .send({ password: 'password123' })\r\n        .expect(400);\r\n      \r\n      expect(response.body.error).toBeDefined();\r\n    });\r\n  });\r\n  \r\n  describe('GET /api/users/:id', () => {\r\n    it('should return user by id', async () => {\r\n      const user = await User.create({\r\n        email: 'test@example.com',\r\n        password: 'hashedpassword'\r\n      });\r\n      \r\n      const token = generateTestToken(user.id);\r\n      \r\n      const response = await request(app)\r\n        .get(`/api/users/${user.id}`)\r\n        .set('Authorization', `Bearer ${token}`)\r\n        .expect(200);\r\n      \r\n      expect(response.body.user.id).toBe(user.id.toString());\r\n    });\r\n    \r\n    it('should return 404 if user not found', async () => {\r\n      const token = generateTestToken('507f1f77bcf86cd799439011');\r\n      \r\n      await request(app)\r\n        .get('/api/users/507f1f77bcf86cd799439011')\r\n        .set('Authorization', `Bearer ${token}`)\r\n        .expect(404);\r\n    });\r\n  });\r\n});\r\n\r\n// E2E Testing\r\n// __tests__/e2e/userFlow.test.js\r\ndescribe('User Flow E2E', () => {\r\n  let authToken;\r\n  let userId;\r\n  \r\n  it('should complete user registration and login flow', async () => {\r\n    // Register user\r\n    const registerResponse = await request(app)\r\n      .post('/api/auth/register')\r\n      .send({\r\n        email: 'e2e@example.com',\r\n        password: 'password123',\r\n        name: 'Test User'\r\n      })\r\n      .expect(201);\r\n    \r\n    userId = registerResponse.body.user.id;\r\n    \r\n    // Login\r\n    const loginResponse = await request(app)\r\n      .post('/api/auth/login')\r\n      .send({\r\n        email: 'e2e@example.com',\r\n        password: 'password123'\r\n      })\r\n      .expect(200);\r\n    \r\n    authToken = loginResponse.body.token;\r\n    \r\n    // Get profile\r\n    const profileResponse = await request(app)\r\n      .get('/api/profile')\r\n      .set('Authorization', `Bearer ${authToken}`)\r\n      .expect(200);\r\n    \r\n    expect(profileResponse.body.user.email).toBe('e2e@example.com');\r\n  });\r\n});\r\n\r\n// Test utilities\r\n// __tests__/utils/testHelpers.js\r\nconst User = require('../../models/User');\r\nconst jwt = require('jsonwebtoken');\r\n\r\nasync function createTestUser(userData = {}) {\r\n  return await User.create({\r\n    email: userData.email || 'test@example.com',\r\n    password: userData.password || 'hashedpassword',\r\n    ...userData\r\n  });\r\n}\r\n\r\nfunction generateTestToken(userId) {\r\n  return jwt.sign(\r\n    { userId, email: 'test@example.com' },\r\n    process.env.JWT_SECRET || 'test-secret',\r\n    { expiresIn: '1h' }\r\n  );\r\n}\r\n\r\nasync function clearDatabase() {\r\n  await User.deleteMany({});\r\n}\r\n\r\n// Jest configuration (jest.config.js)\r\nmodule.exports = {\r\n  testEnvironment: 'node',\r\n  coveragePathIgnorePatterns: [\r\n    '/node_modules/',\r\n    '/__tests__/',\r\n    '/config/'\r\n  ],\r\n  testMatch: [\r\n    '**/__tests__/**/*.test.js'\r\n  ],\r\n  setupFilesAfterEnv: ['<rootDir>/__tests__/setup.js']\r\n};\r\n\r\n// Test setup (__tests__/setup.js)\r\nconst mongoose = require('mongoose');\r\n\r\nbeforeAll(async () => {\r\n  await mongoose.connect(process.env.TEST_DATABASE_URL);\r\n});\r\n\r\nafterAll(async () => {\r\n  await mongoose.connection.dropDatabase();\r\n  await mongoose.connection.close();\r\n});\r\n\r\n// Mocking external services\r\njest.mock('../services/emailService', () => ({\r\n  sendEmail: jest.fn().mockResolvedValue({ success: true })\r\n}));\r\n\r\n// Async testing patterns\r\nit('should handle async operations', async () => {\r\n  const result = await asyncFunction();\r\n  expect(result).toBeDefined();\r\n});\r\n\r\n// Testing error cases\r\nit('should handle errors correctly', async () => {\r\n  await expect(asyncFunctionThatThrows()).rejects.toThrow('Expected error message');\r\n});\r\n```",
    "number": 25
  }
]